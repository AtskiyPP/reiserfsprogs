diff -ruP -x CVS reiserfsprogs-3.x.0j/debugreiserfs/debugreiserfs.c reiserfsprogs-devel/debugreiserfs/debugreiserfs.c
--- reiserfsprogs-3.x.0j/debugreiserfs/debugreiserfs.c	Wed Mar 28 04:35:40 2001
+++ reiserfsprogs-devel/debugreiserfs/debugreiserfs.c	Tue May  1 20:27:30 2001
@@ -84,7 +84,7 @@
       
 	dc = B_N_CHILD (bh, 0);
 	for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++)
-	    print_disk_tree (fs, dc->dc_block_number);
+	    print_disk_tree (fs, dc_block_number(dc));
       
     } else if (is_leaf_node (bh)) {
 	g_stat_info.nr_leaves ++;
@@ -135,8 +135,9 @@
 				  struct reiserfs_de_head * deh)
 {
     printf ("\tCorrupting deh_offset of entry \"%s\" of [%u %u]\n", name,
-	    ih->ih_key.k_dir_id, ih->ih_key.k_objectid);
-    deh->deh_offset = 700;
+	    le32_to_cpu(ih->ih_key.k_dir_id),
+            le32_to_cpu(ih->ih_key.k_objectid));
+    set_deh_offset(deh, 700);
 }
 
 
@@ -300,8 +301,8 @@
 
 		sd = (struct stat_data_v1 *)B_I_PITEM (bh, ih); 
 		reiserfs_warning (stderr, "Changing sd_size of %k from %d to %d\n",
-				   &ih->ih_key, sd->sd_size, value);
-		sd->sd_size = value;
+				   &ih->ih_key, sd_v1_size(sd), value);
+                set_sd_v1_size( sd, value );
 		mark_buffer_dirty (bh);
 		goto cont;		
 	    }
@@ -312,8 +313,8 @@
 
 		sd = (struct stat_data_v1 *)B_I_PITEM (bh, ih); 
 		reiserfs_warning (stderr, "Changing sd_first_direct_byte of %k from %d to %d\n",
-				   &ih->ih_key, sd->sd_first_direct_byte, value);		
-		sd->sd_first_direct_byte = value;
+				   &ih->ih_key, sd_v1_first_direct_byte(sd), value);		
+		set_sd_v1_first_direct_byte( sd, value );
 		mark_buffer_dirty (bh);
 		goto cont;		
 	    }
@@ -332,11 +333,13 @@
 		    continue;
 		}
 		key = &(ih + 1)->ih_key;
-		ih->ih_key.k_dir_id = key->k_dir_id + 1;
+		ih->ih_key.k_dir_id = cpu_to_le32(
+                    le32_to_cpu(key->k_dir_id) + 1 );
 		mark_buffer_dirty (bh);
 	    }
 
-	    if (ih->ih_key.k_objectid != objectid || !is_direntry_ih (ih))
+	    if ( le32_to_cpu(ih->ih_key.k_objectid) != objectid ||
+                 !is_direntry_ih (ih))
 		continue;
 
 	    deh = B_I_DEH (bh, ih);
@@ -366,7 +369,7 @@
 		    break;
 
 		case 'E': /* change entry's deh_objectid */
-		    deh->deh_objectid = new_objectid;
+		    set_deh_objectid(deh, new_objectid);
 		    break;
 
 		default:
@@ -425,6 +428,9 @@
 		die ("recover_file: wrong input K format");
 	    }
 	    printf ("Recovering file (%u, %u)\n", key.k_dir_id, key.k_objectid);
+
+            key.k_dir_id = le32_to_cpu( key.k_dir_id );
+            key.k_objectid = le32_to_cpu( key.k_objectid );
 	    break;
 
 	case 'N':
@@ -499,7 +505,8 @@
 	}
     }
     printf ("recover_file: %Ld bytes recovered of file %s, key %u %u, %d blocks are free and %d are used\n",
-	    recovered, name, key.k_dir_id, key.k_objectid, not_used, used);
+	    recovered, name, le32_to_cpu(key.k_dir_id),
+            le32_to_cpu(key.k_objectid), not_used, used);
 }
 
 
@@ -770,21 +777,21 @@
 {
     int i, j;
     struct item_head * ih;
-    struct reiserfs_de_head * deh;
-
+    struct reiserfs_de_head *deh;
 
     ih = B_N_PITEM_HEAD (bh, 0);
     for (i = 0; i < B_NR_ITEMS (bh); i ++, ih ++) {
-	if ((ih->ih_key.k_dir_id == key->k_dir_id || (int)key->k_dir_id == -1) &&
+	if (ih->ih_key.k_dir_id == key->k_dir_id || (int) le32_to_cpu(key->k_dir_id) == -1 &&
 	    ih->ih_key.k_objectid == key->k_objectid) {
-	    reiserfs_warning (log, "%d-th item of block %lu is item of file %K: %H\n",
-			      i, bh->b_blocknr, key, ih);
+	    fprintf (log, "block %lu has item of file %u %u (item %d)\n",
+		     bh->b_blocknr, key_dir_id(key), key_objectid(key), i);
+	    return;
 	}
 	if (!is_direntry_ih (ih))
 	    continue;
 	deh = B_I_DEH (bh, ih);
 	for (j = 0; j < ih_entry_count (ih); j ++, deh ++) {
-	    if ((deh->deh_dir_id == key->k_dir_id || (int)key->k_dir_id == -1) &&
+	    if ((deh->deh_dir_id == key->k_dir_id || (int) le32_to_cpu(key->k_dir_id) == -1) &&
 		deh->deh_objectid == key->k_objectid) {
 		reiserfs_warning (log, "dir item %d (%H) of block %lu has "
 				  "entry (%d-th) %.*s pointing to %K\n",
@@ -850,7 +857,7 @@
 	getline (&answer, &n, stdin);
 	answer [strlen (answer) - 1] = 0;
 	printf ("Looking for name \"%s\"..\n", answer);
-	key.k_dir_id = 1;
+	key.k_dir_id = le32_to_cpu(1);
     } else {
 	printf ("What key do you want to find: dirid?");
 	getline (&answer, &n, stdin);
@@ -859,6 +866,8 @@
 	getline (&answer, &n, stdin);
 	key.k_objectid = atoi (answer);
 	printf ("looking for (%u %u)\n", key.k_dir_id, key.k_objectid);
+        key.k_dir_id = cpu_to_le32(key.k_dir_id);
+        key.k_objectid = cpu_to_le32(key.k_objectid);
     }
 
     done = 0;
@@ -873,21 +882,21 @@
 	type = who_is_this (bh->b_data, bh->b_size);
 	switch (type) {
 	case THE_JDESC:
-	    if (!key.k_dir_id)
+	    if (! le32_to_cpu(key.k_dir_id))
 		printf ("block %lu is journal descriptor\n", i);
 	    break;
 	case THE_SUPER:
-	    if (!key.k_dir_id)
+	    if (! le32_to_cpu(key.k_dir_id))
 		printf ("block %lu is reiserfs super block\n", i);
 	    break;
 	case THE_INTERNAL:
-	    if (!key.k_dir_id)
+	    if (! le32_to_cpu(key.k_dir_id))
 		printf ("block %lu is reiserfs internal node\n", i);
 	    break;
 	case THE_LEAF:
 	    if (mode == DO_SCAN_FOR_NAME) {
 		look_for_name (bh, answer);
-	    } else if (key.k_dir_id) {
+	    } else if ( le32_to_cpu(key.k_dir_id)) {
 		look_for_key (bh, &key);
 	    } else {
 		printf ("block %lu is reiserfs leaf node\n", i);
diff -ruP -x CVS reiserfsprogs-3.x.0j/debugreiserfs/pack.c reiserfsprogs-devel/debugreiserfs/pack.c
--- reiserfsprogs-3.x.0j/debugreiserfs/pack.c	Thu Mar 29 08:37:14 2001
+++ reiserfsprogs-devel/debugreiserfs/pack.c	Tue May  1 20:27:30 2001
@@ -190,7 +190,7 @@
 	    /* store generation counter if it is != 0 */
 	    pe.mask |= HAS_GEN_COUNTER;
 
-	if (le16_to_cpu (deh->deh_state) != 4)
+	if ( deh_state(deh) != 4)
 	    /* something unusual in deh_state. Store it */
 	    pe.mask |= HAS_STATE;
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/debugreiserfs/unpack.c reiserfsprogs-devel/debugreiserfs/unpack.c
--- reiserfsprogs-3.x.0j/debugreiserfs/unpack.c	Thu Mar 29 08:40:30 2001
+++ reiserfsprogs-devel/debugreiserfs/unpack.c	Tue May  1 20:27:30 2001
@@ -97,7 +97,7 @@
 	fread8 (&mask);
 	fread16 (&entry_len);
 	location -= entry_len;
-	deh->deh_location = location;
+        set_deh_location(deh, location);
 	fread (item + location, entry_len, 1, stdin);
 
 	/* find name length */
@@ -110,19 +110,19 @@
 	if (mask & HAS_DIR_ID)
 	    fread32 (&deh->deh_dir_id);
 	else
-	    deh->deh_dir_id = ih->ih_key.k_objectid;
+	    deh->deh_dir_id = ih->ih_key.k_objectid; /* Both little endian, safe */
 	if (*(item + location) == '.' && namelen == 1)
 	    /* old or new "." */
-	    deh->deh_offset = DOT_OFFSET;
+            set_deh_offset( deh, DOT_OFFSET );
 	else if (*(item + location) == '.' && *(item + location + 1) == '.' && namelen == 2)
 	    /* old or new ".." */
-	    deh->deh_offset = DOT_DOT_OFFSET;
+            set_deh_offset( deh, DOT_DOT_OFFSET );
 	else
-	    deh->deh_offset = GET_HASH_VALUE (hash_func (item + location,
-							 namelen));
+            set_deh_offset( deh, GET_HASH_VALUE (hash_func (item + location,
+							 namelen)));
 	if (mask & HAS_GEN_COUNTER) {
 	    fread16 (&gen_counter);
-	    deh->deh_offset |= gen_counter;
+            set_deh_offset( deh, deh_offset(deh) | gen_counter );
 	}
 
 	if (mask & HAS_STATE)
@@ -314,7 +314,7 @@
 	}
 
 	// we need to set item format before offset unpacking
-	set_key_format (ih, (pi.mask & NEW_FORMAT) ? KEY_FORMAT_2 : KEY_FORMAT_1);
+	set_ih_key_format (ih, (pi.mask & NEW_FORMAT) ? KEY_FORMAT_2 : KEY_FORMAT_1);
 
 	// offset
 	unpack_offset (&pi, ih);
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/check.c reiserfsprogs-devel/fsck/check.c
--- reiserfsprogs-3.x.0j/fsck/check.c	Tue Mar  6 10:31:02 2001
+++ reiserfsprogs-devel/fsck/check.c	Mon Mar 26 18:35:17 2001
@@ -169,7 +169,7 @@
 	
 	dc = B_N_CHILD (bh, 0);
 	for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
-	    reiserfsck_check_tree (dev, dc->dc_block_number, size, comp_func);
+	    reiserfsck_check_tree (dev, dc_block_number(dc), size, comp_func);
 	    g_dkey = B_N_PDELIM_KEY (bh, i);
 	}
     } else if (is_leaf_node (bh)) {
@@ -217,7 +217,7 @@
 	
 	dc = B_N_CHILD (bh, 0);
 	for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
-	    reiserfsck_check_cached_tree (dev, dc->dc_block_number, size);
+	    reiserfsck_check_cached_tree (dev, dc_block_number(dc), size);
 	    g_dkey = B_N_PDELIM_KEY (bh, i);
 	}
     } else if (is_leaf_node (bh)) {
@@ -310,10 +310,14 @@
     for (i = 0; i < B_NR_ITEMS (bh); i ++) {
 	key = B_N_PDELIM_KEY (bh, i);
 	if (//key->k_dir_id >= key->k_objectid ||
-	    key->u.k_offset_v1.k_uniqueness != V1_DIRENTRY_UNIQUENESS && key->u.k_offset_v1.k_uniqueness != V1_DIRECT_UNIQUENESS &&
-	    key->u.k_offset_v1.k_uniqueness != V1_INDIRECT_UNIQUENESS && key->u.k_offset_v1.k_uniqueness != V1_SD_UNIQUENESS &&
-	    key->u.k_offset_v2.k_type != TYPE_DIRENTRY && key->u.k_offset_v2.k_type != TYPE_DIRECT &&
-	    key->u.k_offset_v2.k_type != TYPE_INDIRECT && key->u.k_offset_v2.k_type != TYPE_STAT_DATA //&&
+	    le32_to_cpu(key->u.k_offset_v1.k_uniqueness) != V1_DIRENTRY_UNIQUENESS &&
+            le32_to_cpu(key->u.k_offset_v1.k_uniqueness) != V1_DIRECT_UNIQUENESS &&
+	    le32_to_cpu(key->u.k_offset_v1.k_uniqueness) != V1_INDIRECT_UNIQUENESS &&
+            le32_to_cpu(key->u.k_offset_v1.k_uniqueness) != V1_SD_UNIQUENESS &&
+	    offset_v2_k_type( &(key->u.k_offset_v2) ) != TYPE_DIRENTRY &&
+            offset_v2_k_type( &(key->u.k_offset_v2) ) != TYPE_DIRECT &&
+	    offset_v2_k_type( &(key->u.k_offset_v2) ) != TYPE_INDIRECT &&
+            offset_v2_k_type( &(key->u.k_offset_v2) ) != TYPE_STAT_DATA //&&
 	    //	key->u.k_offset_v1.k_uniqueness != V1_ANY_UNIQUENESS && key->u.k_offset_v2.k_type != TYPE_ANY	
 	    )
 	    return 1;
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/check_tree.c reiserfsprogs-devel/fsck/check_tree.c
--- reiserfsprogs-3.x.0j/fsck/check_tree.c	Wed Mar 28 09:39:28 2001
+++ reiserfsprogs-devel/fsck/check_tree.c	Tue May  1 20:27:30 2001
@@ -182,13 +182,13 @@
 static int bad_block_number (struct super_block * s, unsigned long block)
 {
     if (block >= SB_BLOCK_COUNT (s)) {
-        /*reiserfs_warning ("block out of filesystem boundary found\n");*/
+        reiserfs_warning ( stderr, "bad_block_number: block out of filesystem boundary found (%d), max (%d)\n", block, SB_BLOCK_COUNT(s));
         return 1;
     }
 
     if (not_data_block (s, block)) {
-        /*reiserfs_warning ("not data block (%lu) is used in the tree\n",
-	  block);*/
+        reiserfs_warning ( stderr, "not data block (%lu) is used in the tree\n",
+	  block);
         return 1;
     }
 
@@ -225,13 +225,13 @@
     struct block_head * blkh;
 
     blkh = B_BLK_HEAD (bh);
-    if (le16_to_cpu (blkh->blk_nr_item) > (bh->b_size - BLKH_SIZE) / IH_SIZE) {
+    if (blkh_nr_item(blkh) > (bh->b_size - BLKH_SIZE) / IH_SIZE) {
 	fsck_log ("block %lu has wrong blk_nr_items (%z)\n", 
 		  bh->b_blocknr, bh);
 	return 1;
     }
-    if (le16_to_cpu (blkh->blk_free_space) > 
-	bh->b_size - BLKH_SIZE - IH_SIZE * le16_to_cpu (blkh->blk_nr_item)) {
+    if (blkh_free_space(blkh) > 
+	bh->b_size - BLKH_SIZE - IH_SIZE * blkh_nr_item(blkh)) {
 	fsck_log ("block %lu has wrong blk_free_space %z\n", 
 		  bh->b_blocknr, bh);
 	return 1;
@@ -251,18 +251,18 @@
 	return 0;
 */
     objectid = le32_to_cpu (ih->ih_key.k_objectid);
-    if (!is_objectid_used (fs, objectid)) {
+    if (!is_objectid_used (fs, ih->ih_key.k_objectid)) {
 	/* FIXME: this could be cured right here */
 	fsck_log ("\nbad_stat_data: %lu is marked free, but used by an object %k\n",
 		  objectid, &ih->ih_key);
     }
 
-    if (is_objectid_really_used (proper_id_map (fs), objectid, &pos)) {
+    if (is_objectid_really_used (proper_id_map (fs), ih->ih_key.k_objectid, &pos)) {
 	fsck_log ("\nbad_stat_data: %lu is shared by at least two files\n",
 		  objectid);
 	return 0;
     }
-    mark_objectid_really_used (proper_id_map (fs), objectid);
+    mark_objectid_really_used (proper_id_map (fs), ih->ih_key.k_objectid);
     return 0;
 }
 
@@ -349,7 +349,7 @@
 	/* entry count can not be that big */
 	return 1;
 
-    if (deh[ih_entry_count (ih) - 1].deh_location != DEH_SIZE * ih_entry_count (ih))
+    if (deh_location(&(deh[ih_entry_count (ih) - 1])) != DEH_SIZE * ih_entry_count (ih))
 	/* last entry should start right after array of dir entry headers */
 	return 1;
 
@@ -367,11 +367,13 @@
     set_bit (DEH_Visible, &state);
     /* ok, items looks like a directory */
     for (i = 0; i < ih_entry_count (ih); i ++, deh ++) {
-	if (deh_state (deh) != state) {
+	if ( deh->deh_state != state) { /* JDM not sure why this works, maybe
+        different set_bit? */
 	    fsck_log ("bad_directory_item: block %lu: item %H has entry "
-		      "\"%.*s\" with wrong deh_state %o",
+		      "\"%.*s\" with wrong deh_state %o - expected %o",
 		      bh->b_blocknr, ih, name_length (ih, deh, i), 
-		      name_in_entry (deh, i), deh_state (deh));
+		      name_in_entry (deh, i), deh->deh_state,
+                      state );
 	    if (fsck_fix_fixable (fs)) {
 		deh->deh_state = 0;
 		mark_de_visible (deh);
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/main.c reiserfsprogs-devel/fsck/main.c
--- reiserfsprogs-3.x.0j/fsck/main.c	Fri Mar 30 13:17:54 2001
+++ reiserfsprogs-devel/fsck/main.c	Tue May  1 20:27:30 2001
@@ -6,6 +6,10 @@
 
 #include "../version.h"
 
+extern struct key root_dir_key;
+extern struct key parent_root_dir_key;
+extern struct key lost_found_dir_key;
+
 
 
 #define print_usage_and_exit() die ("Usage: %s [options] "\
@@ -615,6 +619,16 @@
     struct rlimit rlim = {0xffffffff, 0xffffffff};
 
     print_banner ("reiserfsck");
+
+
+    /* initially assigned in semantic.c, but non-constant initializers are
+    * illegal - jdm */
+    root_dir_key.k_dir_id = cpu_to_le32(root_dir_key.k_dir_id);
+    root_dir_key.k_objectid = cpu_to_le32(root_dir_key.k_objectid);
+    parent_root_dir_key.k_dir_id = cpu_to_le32(parent_root_dir_key.k_dir_id);
+    parent_root_dir_key.k_objectid = cpu_to_le32(parent_root_dir_key.k_objectid);
+    lost_found_dir_key.k_dir_id = cpu_to_le32(lost_found_dir_key.k_dir_id);
+    lost_found_dir_key.k_objectid = cpu_to_le32(lost_found_dir_key.k_objectid);
 
     /* this is only needed (and works) when running under 2.4 on regural files */
     if (setrlimit (RLIMIT_FSIZE, &rlim) == -1) {
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/pass0.c reiserfsprogs-devel/fsck/pass0.c
--- reiserfsprogs-3.x.0j/fsck/pass0.c	Fri Mar 30 16:32:31 2001
+++ reiserfsprogs-devel/fsck/pass0.c	Tue May  1 20:27:31 2001
@@ -111,7 +111,7 @@
 	    if (ih_key_format (ih) != KEY_FORMAT_1) {
 		fsck_log ("correct_key_format: ih_key_format of (%H) is set to format 1\n",
 			  ih);
-		set_key_format (ih, KEY_FORMAT_1);
+		set_ih_key_format (ih, KEY_FORMAT_1);
 		return 1;
 	}
 	    return 0;
@@ -120,7 +120,7 @@
 	    if (ih_key_format (ih) != KEY_FORMAT_2) {
 		fsck_log ("correct_key_format: ih_key_format of (%H) is set to format 2\n",
 			  ih);
-		set_key_format (ih, KEY_FORMAT_2);
+		set_ih_key_format (ih, KEY_FORMAT_2);
 		return 1;
 	    }
 	    return 0;
@@ -132,7 +132,7 @@
     if (key_format (&ih->ih_key) != ih_key_format (ih)) {
 	fsck_log ("correct_key_format: ih_key_format of (%H) is set to format found in the key\n",
 		  ih);
-	set_key_format (ih, key_format (&ih->ih_key));
+	set_ih_key_format (ih, key_format (&ih->ih_key));
 	dirty = 1;
     }
     
@@ -290,17 +290,17 @@
 	    /* check and fix "." */
 	    
 	    if (deh_offset (deh + i) != DOT_OFFSET) {
-		deh[i].deh_offset = cpu_to_le32 (DOT_OFFSET);
+		set_deh_offset(&(deh[i]), DOT_OFFSET);
 		mark_buffer_dirty (bh);
 	    }
 	    /* "." must point to the directory it is in */
-	    if (not_of_one_file (&(deh[i].deh_dir_id), &(ih->ih_key))) {
+	    if (not_of_one_file (&(deh[i].deh_dir_id), &(ih->ih_key))) { /* endian safe */
 		fsck_log ("verify_direntry: block %lu, item %H has entry \".\" "
 			  "pointing to (%K) instead of (%K)\n", 
 			  bh->b_blocknr, ih,
 			  &(deh[i].deh_dir_id), &(ih->ih_key));
-		deh[i].deh_dir_id = key_dir_id (&ih->ih_key);
-		deh[i].deh_objectid = key_objectid (&ih->ih_key);
+		deh[i].deh_dir_id = ih->ih_key.k_dir_id; /* both LE */
+		deh[i].deh_objectid = ih->ih_key.k_objectid; /* both LE */
 		mark_buffer_dirty (bh);
 	    }
 	} else if (is_dot_dot (name, name_len)) {
@@ -310,7 +310,7 @@
 	    
 	    /* check and fix ".." */
 	    if (deh_offset (deh + i) != DOT_DOT_OFFSET)
-		deh[i].deh_offset = cpu_to_le32 (DOT_DOT_OFFSET);
+		set_deh_offset(&(deh[i]), DOT_DOT_OFFSET);
 	} else {
 	    int min_length, max_length;
 
@@ -338,8 +338,10 @@
 				  bh->b_blocknr, ih, i, j, name, deh_offset (deh + i));
 			/* FIXME: if next byte is 0 we think that the name is aligned to 8 byte boundary */
 			if (i) {
-			    deh[i - 1].deh_location = cpu_to_le16 (deh_location (deh + i) +
-								   ((name[j] || SB_VERSION (fs) == REISERFS_VERSION_1) ? j : ROUND_UP (j)));
+			    set_deh_location( &(deh[i - 1]),
+                                deh_location (deh + i) +
+                                ((name[j] || SB_VERSION (fs) ==
+                                REISERFS_VERSION_1) ? j : ROUND_UP (j)));
 			    mark_de_good_location (deh + i - 1);
 			    mark_buffer_dirty (bh);
 			}
@@ -376,7 +378,6 @@
 	    
 	    if (deh_offset (deh + i) != DOT_OFFSET) {
 		deh[i].deh_offset = cpu_to_le32 (DOT_OFFSET);
-		mark_buffer_dirty (bh);
 	    }
 	    /* "." must point to the directory it is in */
 	    if (not_of_one_file (&(deh[i].deh_dir_id), &(ih->ih_key))) {
@@ -384,8 +385,8 @@
 			  "pointing to (%K) instead of (%K)\n", 
 			  bh->b_blocknr, ih,
 			  &(deh[i].deh_dir_id), &(ih->ih_key));
-		deh[i].deh_dir_id = key_dir_id (&ih->ih_key);
-		deh[i].deh_objectid = key_objectid (&ih->ih_key);
+		deh[i].deh_dir_id = ih->ih_key.k_dir_id; /* both 32 bit LE */
+		deh[i].deh_objectid = ih->ih_key.k_objectid; /* both 32 bit LE */
 		mark_buffer_dirty (bh);
 	    }
 	} else if (i == 1 && is_dot_dot (name, name_len)) {
@@ -433,108 +434,113 @@
 		mark_de_bad_offset (deh + i);
 	    }
 	}
-    }
-#endif
-
-#ifdef DEBUG_VERIFY_DENTRY
-    printf ("entries with mismatching deh_offsets: ");
-    for (i = 0; i < ih_entry_count (ih); i ++) {
-	if (de_bad_offset (deh + i))
-	    printf ("%d ", i);
-    }
-    printf ("\n");
-#endif /* DEBUG_VERIFY_DENTRY */
+   }
+ #endif
 
-
-    /* correct deh_locations such that code cutting entries will not get
-       screwed up */
-    {
-	int prev_loc;
-	int loc_fixed;
-
-
-	prev_loc = ih_item_len (ih);
-	for (i = 0; i < ih_entry_count (ih); i ++) {
-	    loc_fixed = 0;
-	    if (de_bad_location (deh + i)) {
-		deh[i].deh_location = cpu_to_le16 (prev_loc/* - 1*/);
-		mark_buffer_dirty (bh);
-		loc_fixed = 1;
-	    } else {
-		if (deh_location (deh + i) >= prev_loc) {
-		    deh[i].deh_location = cpu_to_le16 (prev_loc/* - 1*/);
-		    mark_buffer_dirty (bh);
-		    loc_fixed = 1;
-		}
-	    }
-
-	    prev_loc = deh_location (deh + i);
-	    
-	    if (i == ih_entry_count (ih) - 1) {
-		/* last entry starts right after an array of dir entry headers */
-		if (!de_bad (deh + i) &&
-		    deh_location (deh + i) != (DEH_SIZE * ih_entry_count (ih))) {
-		    /* free space in the directory item */
-		    fsck_log ("verify_direntry: block %lu, item %H has free space\n",
-			      bh->b_blocknr, ih);
-		    cut_entry (fs, bh, item_num, ih_entry_count (ih), 0);
-		}
-		if (deh_location (deh + i) != (DEH_SIZE * ih_entry_count (ih))) {
-		    deh[i].deh_location = cpu_to_le16 (DEH_SIZE * ih_entry_count (ih));
-		    loc_fixed = 1;
-		    mark_buffer_dirty (bh);
-		}
-	    }
-
-#ifdef DEBUG_VERIFY_DENTRY
-	    if (loc_fixed)
-		direntries [i] = 1;
-#endif
-	} /* for */
-
-#ifdef DEBUG_VERIFY_DENTRY
-	printf ("entries with fixed deh_locations: ");
-	for (i = 0; i < ih_entry_count (ih); i ++) {
-	    if (direntries [i])
-		printf ("%d ", i);
-	}
-	printf ("\n");
-#endif /* DEBUG_VERIFY_DENTRY */
-
-    }
-
-#ifdef DEBUG_VERIFY_DENTRY
-    printf (" N  location name\n");
-    for (i = 0; i < ih_entry_count (ih); i ++) {
-	if (de_bad (deh + i) ||
-	    (i && de_bad (deh + i - 1)) || /* previous entry marked bad */
-	    (i < ih_entry_count (ih) - 1 && de_bad (deh + i + 1))) { /* next entry is marked bad */
-	    /* print only entries to be deleted and their nearest neighbors */
-	    printf ("%3d: %8d ", i, deh_location (deh + i));
-	    if (de_bad (deh + i))
-		printf ("will be deleted\n");
-	    else
-		printf ("\"%.*s\"\n", name_length (ih, deh + i, i),
-			name_in_entry (deh + i, i));
-	}
-    }
-#endif
-
-    bad = 0;
-    tmp = *ih;
-
-    /* delete entries which are marked bad */
-    for (i = 0; i < ih_entry_count (ih); i ++) {
-	deh = B_I_DEH (bh, ih) + i;
-	if (de_bad (deh)) {
-	    bad ++;
-	    if (ih_entry_count (ih) == 1) {
-		delete_item (fs, bh, item_num);
-		break;
-	    } else {
-		cut_entry (fs, bh, item_num, i, 1);
-	    }
-	    i --;
+ #ifdef DEBUG_VERIFY_DENTRY
+     printf ("entries with mismatching deh_offsets: ");
+     for (i = 0; i < ih_entry_count (ih); i ++) {
+       if (de_bad_offset (deh + i))
+           printf ("%d ", i);
+     }
+     printf ("\n");
+ #endif /* DEBUG_VERIFY_DENTRY */
+
+
+     /* correct deh_locations such that code cutting entries will not get
+        screwed up */
+     {
+       int prev_loc;
+       int loc_fixed;
+
+
+       prev_loc = ih_item_len (ih);
+       for (i = 0; i < ih_entry_count (ih); i ++) {
+           loc_fixed = 0;
+           if (de_bad_location (deh + i)) {
+               set_deh_location(&(deh[i]), prev_loc/* - 1*/);
+               mark_buffer_dirty (bh);
+               loc_fixed = 1;
+           } else {
+               if (deh_location (deh + i) >= prev_loc) {
+                   set_deh_location(&(deh[i]), prev_loc/* - 1*/);
+                   mark_buffer_dirty (bh);
+                   loc_fixed = 1;
+               }
+           }
+
+           prev_loc = deh_location (deh + i);
+
+           if (i == ih_entry_count (ih) - 1) {
+               /* last entry starts right after an array of dir entry headers */
+               if (!de_bad (deh + i) &&
+                   deh_location (deh + i) != (DEH_SIZE * ih_entry_count (ih))) {
+
+                   /* free space in the directory item */
+                   fsck_log ("verify_direntry: block %lu, item %H has free
+pace\n",
+                             bh->b_blocknr, ih);
+                   cut_entry (fs, bh, item_num, ih_entry_count (ih), 0);
+               }
+               if (deh_location (deh + i) != (DEH_SIZE * ih_entry_count (ih)))
+               {
+
+                   set_deh_location(&(deh[i]), DEH_SIZE * ih_entry_count (ih));
+                   loc_fixed = 1;
+                   mark_buffer_dirty (bh);
+               }
+           }
+
+ #ifdef DEBUG_VERIFY_DENTRY
+           if (loc_fixed)
+               direntries [i] = 1;
+ #endif
+       } /* for */
+
+ #ifdef DEBUG_VERIFY_DENTRY
+       printf ("entries with fixed deh_locations: ");
+       for (i = 0; i < ih_entry_count (ih); i ++) {
+           if (direntries [i])
+               printf ("%d ", i);
+       }
+       printf ("\n");
+ #endif /* DEBUG_VERIFY_DENTRY */
+
+     }
+
+ #ifdef DEBUG_VERIFY_DENTRY
+     printf (" N  location name\n");
+     for (i = 0; i < ih_entry_count (ih); i ++) {
+       if (de_bad (deh + i) ||
+           (i && de_bad (deh + i - 1)) || /* previous entry marked bad */
+           (i < ih_entry_count (ih) - 1 && de_bad (deh + i + 1))) { /* next
+ntry is marked bad */
+           /* print only entries to be deleted and their nearest neighbors */
+           printf ("%3d: %8d ", i, deh_location (deh + i));
+           if (de_bad (deh + i))
+               printf ("will be deleted\n");
+           else
+               printf ("\"%.*s\"\n", name_length (ih, deh + i, i),
+                       name_in_entry (deh + i, i));
+       }
+     }
+ #endif
+
+     bad = 0;
+     tmp = *ih;
+
+     /* delete entries which are marked bad */
+     for (i = 0; i < ih_entry_count (ih); i ++) {
+       deh = B_I_DEH (bh, ih) + i;
+       if (de_bad (deh)) {
+           bad ++;
+           if (ih_entry_count (ih) == 1) {
+               delete_item (fs, bh, item_num);
+               break;
+           } else {
+               cut_entry (fs, bh, item_num, i, 1);
+           }
+	   i --;
 	}
     }
     
@@ -578,12 +584,12 @@
     if (get_offset (&ih->ih_key) == DOT_OFFSET) {
 	/* first item of directory - make sure that "." and ".." are in place */
 	if (deh_offset (deh) != DOT_OFFSET || name_in_entry (deh, 0)[0] != '.') {
-	    deh->deh_offset = cpu_to_le32 (DOT_OFFSET);
+	    set_deh_offset(deh, DOT_OFFSET);
 	    name_in_entry (deh, 0)[0] = '.';
 	}
 	if (deh_offset (deh + 1) != DOT_DOT_OFFSET ||
 	    name_in_entry (deh + 1, 1)[0] != '.' || name_in_entry (deh + 1, 1)[1] != '.') {
-	    (deh + 1)->deh_offset = cpu_to_le32 (DOT_DOT_OFFSET);
+	    set_deh_offset((deh + 1), DOT_DOT_OFFSET);
 	    name_in_entry (deh + 1, 1)[0] = '.';
 	    name_in_entry (deh + 1, 1)[1] = '.';
 	}
@@ -602,9 +608,9 @@
 	name_len = prob_name (fs, &entries, total_entry_len, deh_offset (deh));
 	if (!name_len) {
 	    if (!bad_entries) {
-		deh->deh_location = cpu_to_le16 (entries - item);
+                set_deh_location(deh, entries - item);
 	    } else {
-		deh->deh_location = cpu_to_le16 (deh_location (deh + 1) + 1);
+                set_deh_location(deh, deh_location((deh + 1)) + 1 );
 	    }
 	    bad_entries ++;
 	    
@@ -619,7 +625,7 @@
 	
 	/* 'entries' points now to the name which match given offset -
            so, set deh_location */
-	deh->deh_location = cpu_to_le16 (entries - item);
+        set_deh_location(deh, entries - item);
 	deh->deh_state = 0;
 	mark_de_visible (deh);
 	
@@ -737,7 +743,7 @@
 			    set_type (KEY_FORMAT_2, &(ih->ih_key), TYPE_INDIRECT);
 			else
 			    set_type (KEY_FORMAT_2, &(ih->ih_key), TYPE_DIRECT);
-			set_key_format (ih, KEY_FORMAT_2);
+			set_ih_key_format (ih, KEY_FORMAT_2);
 		    } else {
 			/* stat data is old, therefore this item is old too */
 			set_offset (KEY_FORMAT_1, &(ih->ih_key), 1);
@@ -745,7 +751,7 @@
 			    set_type (KEY_FORMAT_1, &(ih->ih_key), TYPE_INDIRECT);
 			else
 			    set_type (KEY_FORMAT_1, &(ih->ih_key), TYPE_DIRECT);
-			set_key_format (ih, KEY_FORMAT_1);
+			set_ih_key_format (ih, KEY_FORMAT_1);
 		    }
 		    fsck_log ("%H\n", ih);
 		    dirty = 1;
@@ -925,7 +931,7 @@
 {
     struct stat_data * sd = (struct stat_data *)item;
 
-    if (ih->ih_key.u.k_offset_v1.k_offset || ih->ih_key.u.k_offset_v1.k_uniqueness) {
+    if (le32_to_cpu(ih->ih_key.u.k_offset_v1.k_offset) || le32_to_cpu(ih->ih_key.u.k_offset_v1.k_uniqueness)) {
 	reiserfs_warning (stderr, "Bad SD? %H\n", ih);
 	return 1;
     }
@@ -937,11 +943,11 @@
 	return 0;
     }
 
-    if (!S_ISDIR (sd->sd_mode) && !S_ISREG(sd->sd_mode) &&
-	!S_ISCHR (sd->sd_mode) && !S_ISBLK(sd->sd_mode) &&
-	!S_ISLNK (sd->sd_mode) && !S_ISFIFO(sd->sd_mode) &&
-	!S_ISSOCK(sd->sd_mode)) {	
-	/*fsck_log ("file %k unexpected mode encountered 0%o\n", &ih->ih_key, sd->sd_mode)*/;
+    if (!S_ISDIR (sd_v2_mode(sd)) && !S_ISREG(sd_v2_mode(sd)) &&
+	!S_ISCHR (sd_v2_mode(sd)) && !S_ISBLK(sd_v2_mode(sd)) &&
+	!S_ISLNK (sd_v2_mode(sd)) && !S_ISFIFO(sd_v2_mode(sd)) &&
+	!S_ISSOCK(sd_v2_mode(sd))) {	
+	/*fsck_log ("file %k unexpected mode encountered 0%o\n", &ih->ih_key, sd_v2_mode(sd))*/;
     }
     return 0;
 }
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/pass1.c reiserfsprogs-devel/fsck/pass1.c
--- reiserfsprogs-3.x.0j/fsck/pass1.c	Thu Mar 29 17:36:31 2001
+++ reiserfsprogs-devel/fsck/pass1.c	Tue May  1 20:27:31 2001
@@ -200,7 +200,7 @@
 	pathrelse (&path_to_right_neighbor);
     }
     else
-	used_space = B_N_CHILD (bh, pos + 1)->dc_size;
+	used_space = dc_size(B_N_CHILD (bh, pos + 1));
     
     if (B_FREE_SPACE (new) >= used_space -
 	(are_items_mergeable (B_N_PITEM_HEAD (new, B_NR_ITEMS (new) - 1), (struct item_head *)right_dkey, new->b_size) ? IH_SIZE : 0))
@@ -222,7 +222,7 @@
 	//set_le_key_k_offset (ih_version(ih), key, B_I_DEH (bh, ih)[I_ENTRY_COUNT (ih) - 1].deh_offset);
 	//set_le_key_k_type (ih_version(ih), key, TYPE_DIRENTRY);
 	set_offset (KEY_FORMAT_1, key, 
-			     le32_to_cpu (B_I_DEH (bh, ih)[ih_entry_count (ih) - 1].deh_offset));
+			     deh_offset (&(B_I_DEH (bh, ih)[ih_entry_count (ih) - 1])));
 
     } else if (!is_stat_data_key (key))
 	/* get key of the last byte, which is contained in the item */
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/pass2.c reiserfsprogs-devel/fsck/pass2.c
--- reiserfsprogs-3.x.0j/fsck/pass2.c	Thu Mar 29 07:56:54 2001
+++ reiserfsprogs-devel/fsck/pass2.c	Tue May  1 20:27:31 2001
@@ -21,14 +21,14 @@
 
 
 /* in list of this structures we store what has been
-   relocated. */
+   relocated. Directories can not be reallocated. */
 struct relocated {
     unsigned long old_dir_id;
     unsigned long old_objectid;
     unsigned long new_objectid;
-    /*mode_t mode;*/
+    mode_t mode;
     struct relocated * next;
-};
+}; /* in disk byte order */
 
 
 /* all relocated files will be linked into lost+found directory at the
@@ -37,6 +37,7 @@
 
 
 /* return objectid the object has to be remapped with */
+/* returns little endian objectid */
 __u32 objectid_for_relocation (struct key * key)
 {
     struct relocated * cur;
@@ -57,8 +58,9 @@
     cur->new_objectid = get_unused_objectid (fs);
     cur->next = relocated_list;
     relocated_list = cur;
-    fsck_log ("relocation: (%K) is relocated to (%lu, %lu)\n",
-	      key, key->k_dir_id, cur->new_objectid);
+    fsck_log ("relocation: (%K) is relocated to (%lu, %lu)."
+	      "look for it in the lost+found\n",
+	      key, key_dir_id(key), le32_to_cpu(cur->new_objectid));
     return cur->new_objectid;
 }
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/semantic.c reiserfsprogs-devel/fsck/semantic.c
--- reiserfsprogs-3.x.0j/fsck/semantic.c	Fri Mar 30 13:16:53 2001
+++ reiserfsprogs-devel/fsck/semantic.c	Tue May  1 20:27:31 2001
@@ -4,6 +4,7 @@
 #include "fsck.h"
 
 
+/* the k_dir_id and k_objectid members are endian swapped in main() */
 struct key root_dir_key = {REISERFS_ROOT_PARENT_OBJECTID,
 			   REISERFS_ROOT_OBJECTID, {{0, 0},}};
 struct key parent_root_dir_key = {0, REISERFS_ROOT_PARENT_OBJECTID, {{0, 0},}};
@@ -107,39 +108,39 @@
 	switch (field) {
 	case GET_SD_MODE:
 	    if (set)
-		sd_v1->sd_mode = cpu_to_le16 (*(__u16 *)value);
+		set_sd_v1_mode(sd_v1, *(__u16 *)value );
 	    else
-		*(__u16 *)value = le16_to_cpu (sd_v1->sd_mode);
+		*(__u16 *)value = sd_v1_mode(sd_v1);
 	    break;
 
 	case GET_SD_SIZE:
 	    /* value must point to 64 bit int */
 	    if (set)
-		sd_v1->sd_size = cpu_to_le32 (*(__u64 *)value);
+		set_sd_v1_size(sd_v1, *(__u64 *)value);
 	    else
-		*(__u64 *)value = le32_to_cpu (sd_v1->sd_size);
+		*(__u64 *)value = sd_v1_size(sd_v1);
 	    break;
 
 	case GET_SD_BLOCKS:
 	    if (set)
-		sd_v1->u.sd_blocks = cpu_to_le32 (*(__u32 *)value);
+		set_sd_v1_blocks(sd_v1, *(__u32 *)value);
 	    else
-		*(__u32 *)value = le32_to_cpu (sd_v1->u.sd_blocks);
+		*(__u32 *)value = sd_v1_blocks(sd_v1);
 	    break;
 
 	case GET_SD_NLINK:
 	    /* value must point to 32 bit int */
 	    if (set)
-		sd_v1->sd_nlink = cpu_to_le16 (*(__u32 *)value);
+		set_sd_v1_nlink(sd_v1, *(__u32 *)value);
 	    else
-		*(__u32 *)value = le16_to_cpu (sd_v1->sd_nlink);
+		*(__u32 *)value = sd_v1_nlink(sd_v1);
 	    break;
 
 	case GET_SD_FIRST_DIRECT_BYTE:
 	    if (set)
-		sd_v1->sd_first_direct_byte = cpu_to_le32 (*(__u32 *)value);
+		set_sd_v1_first_direct_byte(sd_v1, *(__u32 *)value);
 	    else
-		*(__u32 *)value = le32_to_cpu (sd_v1->sd_first_direct_byte);
+		*(__u32 *)value = sd_v1_first_direct_byte(sd_v1);
 	    break;
 	    
 	default:
@@ -151,30 +152,30 @@
 	switch (field) {
 	case GET_SD_MODE:
 	    if (set)
-		sd_v2->sd_mode = cpu_to_le16 (*(__u16 *)value);
+		set_sd_v2_mode(sd_v2, *(__u16 *)value);
 	    else
-		*(__u16 *)value = le16_to_cpu (sd_v2->sd_mode);
+		*(__u16 *)value = sd_v2_mode(sd_v2);
 	    break;
 
 	case GET_SD_SIZE:
 	    if (set)
-		sd_v2->sd_size = cpu_to_le64 (*(__u64 *)value);
+		set_sd_v2_size(sd_v2, *(__u64 *)value);
 	    else
-		*(__u64 *)value = le64_to_cpu (sd_v2->sd_size);
+		*(__u64 *)value = sd_v2_size(sd_v2);
 	    break;
 
 	case GET_SD_BLOCKS:
 	    if (set)
-		sd_v2->sd_blocks = cpu_to_le32 (*(__u32 *)value);
+		set_sd_v2_blocks(sd_v2, *(__u32 *)value);
 	    else
-		*(__u32 *)value = le32_to_cpu (sd_v2->sd_blocks);
+		*(__u32 *)value = sd_v2_blocks(sd_v2);
 	    break;
 
 	case GET_SD_NLINK:
 	    if (set)
-		sd_v2->sd_nlink = cpu_to_le32 (*(__u32 *)value);
+		set_sd_v2_nlink(sd_v2, *(__u32 *)value);
 	    else
-		*(__u32 *)value = le32_to_cpu (sd_v2->sd_nlink);
+		*(__u32 *)value = sd_v2_nlink(sd_v2);
 	    break;
 
 	case GET_SD_FIRST_DIRECT_BYTE:
@@ -304,7 +305,6 @@
     return 0;
 }
 
-
 /* return values for check_regular_file and check_semantic_tree */
 #define OK 0
 #define STAT_DATA_NOT_FOUND -1
@@ -382,7 +382,7 @@
     ih->ih_key.k_objectid = new_objectid;
 
     /* put all items removed back into tree */
-    while (si) {
+    while (si) { /* XXX JDM CHECK THIS */
 	fsck_log ("relocate_dir: move %H to ", &si->si_ih);
 	si->si_ih.ih_key.k_objectid = new_objectid;
 	fsck_log ("%H\n", &si->si_ih);
@@ -604,23 +604,23 @@
 	    reiserfs_panic ("get_next_directory_item: item %k: hidden entry %d \'%.*s\'\n",
 			    key, i, namelen, name);
 
-	if (deh->deh_offset == DOT_OFFSET) {
+	if (deh_offset(deh) == DOT_OFFSET) {
 	    if (not_of_one_file (&(deh->deh_dir_id), key))
 		//deh->deh_objectid != REISERFS_ROOT_PARENT_OBJECTID)/*????*/ {
 		reiserfs_panic ("get_next_directory_item: wrong \".\" found %k\n", key);
 	}
 
-	if (deh->deh_offset == DOT_DOT_OFFSET) {
+	if (deh_offset(deh) == DOT_DOT_OFFSET) {
 	    /* set ".." so that it points to the correct parent directory */
 	    if (comp_short_keys (&(deh->deh_dir_id), parent) &&
-		deh->deh_objectid != REISERFS_ROOT_PARENT_OBJECTID)/*???*/ {
+		deh_objectid(deh) != REISERFS_ROOT_PARENT_OBJECTID)/*???*/ {
 		/* FIXME */
 		fsck_log ("get_next_directory_item: %k: \"..\" pointes to [%K], "
 			      "should point to [%K]",
 			      key, (struct key *)(&(deh->deh_dir_id)), parent);
 		if (fsck_mode (fs) == FSCK_REBUILD) {
-		    deh->deh_dir_id = parent->k_dir_id;
-		    deh->deh_objectid = parent->k_objectid;
+		    deh->deh_dir_id = parent->k_dir_id; /* both le */
+		    deh->deh_objectid = parent->k_objectid; /* both le */
 		    mark_buffer_dirty (bh);
 		    fsck_log (" - fixed\n");
 		} else
@@ -658,13 +658,13 @@
 {
     key->k_dir_id = deh->deh_dir_id;
     key->k_objectid = deh->deh_objectid;
-    key->u.k_offset_v1.k_offset = SD_OFFSET;
-    key->u.k_offset_v1.k_uniqueness = V1_SD_UNIQUENESS;
+    key->u.k_offset_v1.k_offset = cpu_to_le32(SD_OFFSET);
+    key->u.k_offset_v1.k_uniqueness = cpu_to_le32(V1_SD_UNIQUENESS);
 
     entry_key->k_dir_id = ih->ih_key.k_dir_id;
     entry_key->k_objectid = ih->ih_key.k_objectid;
     entry_key->u.k_offset_v1.k_offset = deh->deh_offset;
-    entry_key->u.k_offset_v1.k_uniqueness = DIRENTRY_UNIQUENESS;
+    entry_key->u.k_offset_v1.k_uniqueness = cpu_to_le32(DIRENTRY_UNIQUENESS);
 }
 
 
@@ -798,8 +798,8 @@
     reiserfs_add_entry (fs, key, "..", parent, 1 << IH_Unreachable);
 
     item_key = *key;
-    item_key.u.k_offset_v1.k_offset = DOT_OFFSET;
-    item_key.u.k_offset_v1.k_uniqueness = DIRENTRY_UNIQUENESS;
+    item_key.u.k_offset_v1.k_offset = cpu_to_le32(DOT_OFFSET);
+    item_key.u.k_offset_v1.k_uniqueness = cpu_to_le32(DIRENTRY_UNIQUENESS);
 
     /* save stat data's size and st_blocks */
     get_sd_size (ih, sd, &saved_size);
@@ -866,8 +866,8 @@
 		    tmp_deh = B_I_DEH (get_bh (&path), get_ih (&path)) + path.pos_in_item;
 		    fsck_log ("name \"%.*s\" of dir %K pointing to %K updated to point to ",
 			      namelen, name, &tmp_ih.ih_key, &tmp_deh->deh_dir_id);
-		    tmp_deh->deh_dir_id = cpu_to_le32 (relocated_ih.ih_key.k_dir_id);
-		    tmp_deh->deh_objectid = cpu_to_le32 (relocated_ih.ih_key.k_objectid);
+		    tmp_deh->deh_dir_id = cpu_to_le32 (relocated_ih.ih_key.k_dir_id); /* both le */
+		    tmp_deh->deh_objectid = cpu_to_le32 (relocated_ih.ih_key.k_objectid); /* both le */
 		    fsck_log ("%K\n",  &tmp_deh->deh_dir_id);
 		    mark_buffer_dirty (get_bh (&path));
 		}
@@ -935,7 +935,7 @@
        datas (v1 and v2) */
     struct stat_data_v1 * sd_v1 = sd;
 
-    return !(S_ISDIR (le16_to_cpu (sd_v1->sd_mode)));
+    return !(S_ISDIR (sd_v1_mode(sd_v1)));
 }
 
 
@@ -948,12 +948,12 @@
     if (ih_item_len (ih) == SD_V1_SIZE && ih_key_format (ih) != KEY_FORMAT_1) {
 	fsck_log ("zero_nlink: %H had wrong keys format %d, fixed to %d",
 		  ih, ih_key_format (ih), KEY_FORMAT_1);
-	set_key_format (ih, KEY_FORMAT_1);
+	set_ih_key_format (ih, KEY_FORMAT_1);
     }
     if (ih_item_len (ih) == SD_SIZE && ih_key_format (ih) != KEY_FORMAT_2) {
 	fsck_log ("zero_nlink: %H had wrong keys format %d, fixed to %d",
 		  ih, ih_key_format (ih), KEY_FORMAT_2);
-	set_key_format (ih, KEY_FORMAT_2);
+	set_ih_key_format (ih, KEY_FORMAT_2);
     }
 
     set_sd_nlink (ih, sd, &zero);
@@ -1217,8 +1217,8 @@
 
     stats(fs)->directories ++;
     next_item_key = *key;
-    next_item_key.u.k_offset_v1.k_offset = DOT_OFFSET;
-    next_item_key.u.k_offset_v1.k_uniqueness = DIRENTRY_UNIQUENESS;
+    next_item_key.u.k_offset_v1.k_offset = cpu_to_le32(DOT_OFFSET);
+    next_item_key.u.k_offset_v1.k_uniqueness = cpu_to_le32(DIRENTRY_UNIQUENESS);
 
 
     dir_size = 0;
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/ufile.c reiserfsprogs-devel/fsck/ufile.c
--- reiserfsprogs-3.x.0j/fsck/ufile.c	Fri Mar 23 09:59:03 2001
+++ reiserfsprogs-devel/fsck/ufile.c	Tue May  1 20:27:31 2001
@@ -60,7 +60,7 @@
 
 
     /* direct item to insert */
-    set_key_format (&ins_ih, ih_key_format (ih));
+    ins_ih.ih_formats.ih_format.key_format = ih->ih_formats.ih_format.key_format; /* both le */
     ins_ih.ih_key.k_dir_id = ih->ih_key.k_dir_id;
     ins_ih.ih_key.k_objectid = ih->ih_key.k_objectid;
     set_type_and_offset (ih_key_format (ih), &ins_ih.ih_key,
@@ -445,7 +445,7 @@
 	    (*pos_in_coming_item) ++;
 	}
     }
-    set_key_format (&indih, ih_key_format (ih));
+    indih.ih_formats.ih_format.key_format = ih->ih_formats.ih_format.key_format;
     //ih_version(&indih) = ih_version(ih);
     copy_key (&(indih.ih_key), &(ih->ih_key));
     set_offset (key_format (&(ih->ih_key)), &indih.ih_key, 1);
@@ -538,7 +538,7 @@
 	struct item_head insih;
 
 	copy_key (&(insih.ih_key), &key);
-	set_key_format (&insih, key_format (&key));
+	set_ih_key_format (&insih, key_format (&key));
 	set_type (ih_key_format (&insih), &insih.ih_key, TYPE_INDIRECT);
 	set_free_space (&insih, ni.unfm_freespace);
 //    insih.u.ih_free_space = ni.unfm_freespace;
diff -ruP -x CVS reiserfsprogs-3.x.0j/fsck/uobjectid.c reiserfsprogs-devel/fsck/uobjectid.c
--- reiserfsprogs-3.x.0j/fsck/uobjectid.c	Wed Mar 28 10:55:49 2001
+++ reiserfsprogs-devel/fsck/uobjectid.c	Tue May  1 20:27:31 2001
@@ -12,6 +12,7 @@
 
 
 /* is it marked used in super block's objectid map */
+/* objectid is little endian */
 int is_objectid_used (reiserfs_filsys_t s, __u32 objectid)
 {
     __u32 * objectid_map;
@@ -20,15 +21,16 @@
     objectid_map = (__u32 *)((char *)(s->s_rs) + (sb_size(s)));
   
     while (i < SB_OBJECTID_MAP_SIZE (s)) {
-	if (objectid == objectid_map[i]) {
+	if (objectid == objectid_map[i]) { /* equality, endian safe */
 	    return 1;      /* objectid is used */
 	}
 	
-	if (objectid > objectid_map[i] && objectid < objectid_map[i+1]) {
+	if ( le32_to_cpu(objectid) > le32_to_cpu(objectid_map[i]) &&
+             le32_to_cpu(objectid) < le32_to_cpu(objectid_map[i+1])) {
 	    return 1;	/* objectid is used */
 	}
 	
-	if (objectid < objectid_map[i])
+	if (le32_to_cpu(objectid) < le32_to_cpu(objectid_map[i]))
 	    break;
 
 	i += 2;
@@ -78,26 +80,27 @@
    insert the new id).  if smth goes wrong or ubin_search_id stops
    working properly check_id_search_result should help to find raised
    problems */
+/* id is LE */
 static void check_id_search_result(struct id_map * map, int res, __u32 pos,
 				   __u32 id)
 {
     if (res != ITEM_FOUND && res != ITEM_NOT_FOUND)
         die("check_id_search_result: get wrong result from ubin_search (%d)", res);
 
-    if (res == 1 && *(map->m_begin + pos) != id)
-        die("check_id_search_result: wrong id found %u %u", id, *(map->m_begin + pos));
+    if (res == 1 && map->m_begin[pos] != id)
+        die("check_id_search_result: wrong id found %u %u", id, map->m_begin[pos]);
 
     if (res == 1)
     {
         if (pos > map->m_used_slots_count)
             die("check_id_search_result: get bad position (%u), used %u", 
 		pos, map->m_used_slots_count);
-        if (pos >= 0 && pos <= map->m_used_slots_count && *(map->m_begin + pos - 1) >= id)
+        if (pos >= 0 && pos <= map->m_used_slots_count && map->m_begin[pos - 1] >= id)
             die("check_id_search_result: previous id (%u) not less than (%u)",
-		*(map->m_begin + pos - 1), id);
-        if (pos >= 0 && pos < map->m_used_slots_count && *(map->m_begin + pos) < id)
+		map->m_begin[pos - 1], id);
+        if (pos >= 0 && pos < map->m_used_slots_count && map->m_begin[pos] < id)
             die("check_id_search_result: found id (%u) not much than (%u)",
-		*(map->m_begin + pos), id);
+		map->m_begin[pos], id);
     }
 }
 
@@ -109,9 +112,9 @@
     id1 = p1;
     id2 = p2;    
 
-    if ( *id1 < *id2 )
+    if ( le32_to_cpu(*id1) < le32_to_cpu(*id2) )
         return -1;
-    if ( *id1 > *id2 )
+    if ( le32_to_cpu(*id1) > le32_to_cpu(*id2) )
         return 1;
     return 0;
 }
@@ -141,6 +144,7 @@
 
 
 /* return 1 if id is marked used, 0 otherwise */
+/* id is little endian */
 int is_objectid_really_used (struct id_map * map, __u32 id, int * ppos)
 {
     int res;
@@ -172,12 +176,13 @@
     int i;
 
     for (i = 1; i < map->m_used_slots_count; i ++)
-	if (map->m_begin [i - 1] >= map->m_begin [i])
+	if (le32_to_cpu(map->m_begin [i - 1]) >= le32_to_cpu(map->m_begin [i]))
 	    die ("check_objectid_map: map corrupted");
 }
 
 
 /* returns 1 objectid is marked used already, 0 otherwise */
+/* id is little endian */
 int mark_objectid_really_used (struct id_map * map, __u32 id)
 {
     int pos;
@@ -196,9 +201,9 @@
             grow_id_map (map);
 
         /* id + 1 is used, change id + 1 to id and exit */
-        if ( id + 1 == le32_to_cpu (map->m_begin[pos]) ) {
+        if ( le32_to_cpu(id) + 1 == le32_to_cpu (map->m_begin[pos]) ) {
 	    /* we can mark id as used w/o expanding of id map */
-	    map->m_begin[pos] = cpu_to_le32 (id);
+	    map->m_begin[pos] = id;
 
 	    check_objectid_map (map);
 	    return 0;
@@ -212,8 +217,8 @@
             memmove (map->m_begin + pos + 2, map->m_begin + pos, (map->m_used_slots_count - pos) * sizeof (__u32));
 
         map->m_used_slots_count += 2;
-        map->m_begin[pos] = cpu_to_le32 (id);
-        map->m_begin[pos+1] = cpu_to_le32 (id + 1);
+        map->m_begin[pos] = id;
+        map->m_begin[pos+1] = cpu_to_le32 (le32_to_cpu(id) + 1);
 
 	check_objectid_map (map);
 
@@ -221,12 +226,12 @@
     }
 
     /* id found in the map. pos is odd position () */
-    map->m_begin[pos] = cpu_to_le32 (id + 1);
+    map->m_begin[pos] = cpu_to_le32 (le32_to_cpu(id) + 1);
     
     /* if end id of current interval == start id of next interval we
        eliminated a sequence of unused objectids */
     if (pos + 1 < map->m_used_slots_count &&
-	map->m_begin[pos + 1] == map->m_begin[pos]) {
+	map->m_begin[pos + 1] == map->m_begin[pos]) { /* safe, both are le */
 	memmove (map->m_begin + pos, map->m_begin + pos + 2, (map->m_used_slots_count - pos - 2) * sizeof (__u32));
 	map->m_used_slots_count -= 2;
 	try_to_shrink_id_map (map);
diff -ruP -x CVS reiserfsprogs-3.x.0j/include/reiserfs_fs.h reiserfsprogs-devel/include/reiserfs_fs.h
--- reiserfsprogs-3.x.0j/include/reiserfs_fs.h	Fri Mar 30 08:47:58 2001
+++ reiserfsprogs-devel/include/reiserfs_fs.h	Tue May  1 20:27:31 2001
@@ -9,6 +9,8 @@
  *
  */
 
+
+
 /* in reading the #defines, it may help to understand that they employ
  the following abbreviations:
 
@@ -33,6 +35,10 @@
 */
 
 #include <limits.h>
+#include <endian.h>
+#if __BYTE_ORDER != __LITTLE_ENDIAN
+#define USE_ENDIAN_CONVERSION_MACROS
+#endif
 
 /* NEW_GET_NEW_BUFFER will try to allocate new blocks better */
 /*#define NEW_GET_NEW_BUFFER*/
@@ -342,10 +348,59 @@
 } __attribute__ ((__packed__));
 
 struct offset_v2 {
-    __u64 k_offset:60;
-    __u64 k_type: 4; // TYPE_STAT_DATA | TYPE_INDIRECT | TYPE_DIRECT | TYPE_DIRENTRY
+    union {
+        struct {
+#ifndef USE_ENDIAN_CONVERSION_MACROS
+    /* little endian */
+            __u64 k_offset:60;
+            __u64 k_type: 4; // TYPE_STAT_DATA | TYPE_INDIRECT | TYPE_DIRECT | TYPE_DIRENTRY
+#else
+    /* big endian */
+            __u64 k_type: 4; // TYPE_STAT_DATA | TYPE_INDIRECT | TYPE_DIRECT | TYPE_DIRENTRY
+            __u64 k_offset:60;
+#endif
+        } offset;
+        __u64 em_offset;
+    } u;
 } __attribute__ ((__packed__));
 
+#ifdef USE_ENDIAN_CONVERSION_MACROS
+extern inline __u16 offset_v2_k_type( const struct offset_v2 *v2 )
+{
+    struct offset_v2 tmp;
+    tmp.u.em_offset = le64_to_cpu( v2->u.em_offset );
+    return tmp.u.offset.k_type;
+}
+ 
+extern inline void set_offset_v2_k_type( struct offset_v2 *v2, int type )
+{
+    struct offset_v2 tmp;
+    tmp.u.em_offset = le64_to_cpu( v2->u.em_offset );
+    tmp.u.offset.k_type = type;
+    v2->u.em_offset = cpu_to_le64( tmp.u.em_offset );
+}
+ 
+extern inline loff_t offset_v2_k_offset( const struct offset_v2 *v2 )
+{
+    struct offset_v2 tmp;
+    tmp.u.em_offset = le64_to_cpu( v2->u.em_offset );
+    return tmp.u.offset.k_offset;
+}
+ 
+extern inline void set_offset_v2_k_offset( struct offset_v2 *v2, loff_t offset
+){
+    struct offset_v2 tmp;
+    tmp.u.em_offset = le64_to_cpu( v2->u.em_offset );
+    tmp.u.offset.k_offset = offset;
+    v2->u.em_offset = cpu_to_le64( tmp.u.em_offset );
+}
+#else
+# define offset_v2_k_type(v2)           ((v2)->u.offset.k_type)
+# define set_offset_v2_k_type(v2,val)   ((v2)->u.offset.k_type = (val))
+# define offset_v2_k_offset(v2)         ((v2)->u.offset.k_offset)
+# define set_offset_v2_k_offset(v2,val) ((v2)->u.offset.k_offset = (val))
+#endif
+
 
 /* Key of the object drop determines its location in the S+tree, and is
    composed of 4 components */
@@ -356,7 +411,7 @@
     union {
 	struct offset_v1 k_offset_v1;
 	struct offset_v2 k_offset_v2;
-    } u;
+    } __attribute__ ((__packed__)) u;
 } __attribute__ ((__packed__));
 
 #define key_dir_id(key)                 (le32_to_cpu((key)->k_dir_id))
@@ -421,15 +476,26 @@
 	__u16 ih_entry_count; /* Iff this is a directory item, this field
 				 equals the number of directory entries in the
 				 directory item. */
-    } u;
+    } __attribute__ ((__packed__)) u;
     __u16 ih_item_len;           /* total size of the item body */
     __u16 ih_item_location;      /* an offset to the item body within the
                                     block */
-    struct {
-	__u16 key_format : 12; /* KEY_FORMAT_1 or KEY_FORMAT_2. This is not
-				     necessary, but we have space, let use it */
-	__u16 fsck_need : 4;   /* fsck set here its flag (reachable/unreachable) */
-    } ih_format;
+    union {
+        struct {
+#ifndef USE_ENDIAN_CONVERSION_MACROS                                            
+            /* for little endian systems */
+            __u16 key_format : 12; /* KEY_FORMAT_1 or KEY_FORMAT_2. This is not
+                                    necessary, but we have space, let use it */
+            __u16 fsck_need : 4;   /* fsck set here its flag (reachable/unreachable) */
+#else
+            /* for big endian systems */
+            __u16 fsck_need : 4;   /* fsck set here its flag (reachable/unreachable) */
+            __u16 key_format : 12; /* KEY_FORMAT_1 or KEY_FORMAT_2. This is not
+                                    necessary, but we have space, let use it */
+#endif
+        } ih_format;
+        __u16 em_ih_format; /* format used for endian manipulations */
+    } ih_formats;
 } __attribute__ ((__packed__));
 
 
@@ -443,8 +509,44 @@
 #define ih_location(ih) (le16_to_cpu ((ih)->ih_item_location))
 #define set_ih_location(ih,x) ((ih)->ih_item_location = cpu_to_le16 (x))
 
-#define ih_key_format(ih) (le16_to_cpu ((ih)->ih_format.key_format))
-#define set_key_format(ih,x) ((ih)->ih_format.key_format = cpu_to_le16 (x))
+#ifdef USE_ENDIAN_CONVERSION_MACROS
+    /* UGH. This is an attempt to deal with the pain that is endian safe
+    * bitfields. -jeff */
+extern inline __u16 ih_key_format( const struct item_head *ih )
+{
+    struct item_head tmp;
+    tmp.ih_formats.em_ih_format = le16_to_cpu( ih->ih_formats.em_ih_format );
+    return tmp.ih_formats.ih_format.key_format;
+}
+
+extern inline void set_ih_key_format( struct item_head *ih, __u16 val )
+{
+    struct item_head tmp;
+    tmp.ih_formats.em_ih_format = le16_to_cpu( ih->ih_formats.em_ih_format );
+    tmp.ih_formats.ih_format.key_format = val;
+    ih->ih_formats.em_ih_format = cpu_to_le16( tmp.ih_formats.em_ih_format );
+}
+
+extern inline __u16 ih_fsck_need( const struct item_head *ih )
+{
+    struct item_head tmp;
+    tmp.ih_formats.em_ih_format = le16_to_cpu( ih->ih_formats.em_ih_format );
+    return tmp.ih_formats.ih_format.fsck_need;
+}
+
+extern inline void set_ih_fsck_need( struct item_head *ih, __u16 val )
+{
+    struct item_head tmp;
+    tmp.ih_formats.em_ih_format = le16_to_cpu( ih->ih_formats.em_ih_format );
+    tmp.ih_formats.ih_format.fsck_need = val;
+    ih->ih_formats.em_ih_format = cpu_to_le16( tmp.ih_formats.em_ih_format );
+}
+#else
+# define ih_key_format(ih) ((ih)->ih_formats.ih_format.key_format)
+# define set_ih_key_format(ih,val) ((ih)->ih_formats.ih_format.key_format = (val))
+# define ih_fsck_need(ih) ((ih)->ih_formats.ih_format.fsck_need)
+# define set_ih_fsck_need(ih,val) ((ih)->ih_formats.ih_format.fsck_need = (val))
+#endif
 
 
 // FIXME: ih_free_space does not appear to be very important, but we
@@ -468,14 +570,30 @@
 #define IH_Unreachable 1
 
 /* Bad item flag is set temporary by recover_leaf */
-#define mark_ih_bad(ih) ((ih)->ih_format.fsck_need |= IH_Bad)
-#define ih_bad(ih) test_bit (IH_Bad, &((ih)->ih_format.fsck_need))
-#define unmark_item_bad(ih) clear_bit (IH_Bad,  &((ih)->ih_format.fsck_need))
+extern inline __u16 mark_ih_bad( struct item_head *ih )
+{
+    set_ih_fsck_need(ih, ih_fsck_need(ih) | IH_Bad );
+    return ih_fsck_need(ih);
+}
+
+extern inline __u16 ih_bad( struct item_head *ih )
+{
+    __u16 tmp = ih_fsck_need(ih);
+    return test_bit(IH_Bad, &tmp );
+}
+
+extern inline __u16 unmark_item_bad( struct item_head *ih )
+{
+    __u16 tmp = ih_fsck_need(ih);
+    clear_bit( IH_Bad, &tmp );
+    set_ih_fsck_need( ih, tmp );
+    return tmp;
+}
 
 /* Unreachable bit is set on tree rebuilding and is cleared in semantic pass */
-#define mark_ih_ok(ih) ((ih)->ih_format.fsck_need = 0)
-#define ih_reachable(ih) (!(ih)->ih_format.fsck_need & IH_Unreachable)
-#define mark_ih_unreachable(ih) ((ih)->ih_format.fsck_need |= IH_Unreachable)
+#define mark_ih_ok(ih) ((ih)->ih_formats.ih_format.fsck_need = 0) /* endian safe if 0 */
+#define ih_reachable(ih) (!ih_fsck_need(ih) & IH_Unreachable)
+#define mark_ih_unreachable(ih) (set_ih_fsck_need(ih, ih_fsck_need(ih) | IH_Unreachable))
 
 
 
@@ -510,7 +628,13 @@
 			    (supported for leaf level nodes only) */
 };
 
-#define BLKH_SIZE (sizeof(struct block_head))
+#define BLKH_SIZE                    (sizeof(struct block_head))
+#define blkh_level(blkh)             (le16_to_cpu((blkh)->blk_level))
+#define set_blkh_level(blkh,v)       ((blkh)->blk_level = cpu_to_le16((v)))
+#define blkh_nr_item(blkh)           (le16_to_cpu((blkh)->blk_nr_item))
+#define set_blkh_nr_item(blkh,v)     ((blkh)->blk_nr_item = cpu_to_le16((v)))
+#define blkh_free_space(blkh)        (le16_to_cpu((blkh)->blk_free_space))
+#define set_blkh_free_space(blkh,v)  ((blkh)->blk_free_space = cpu_to_le16((v)))
 
 /*
  * values for blk_type field
@@ -521,25 +645,25 @@
 #define DISK_LEAF_NODE_LEVEL  1 /* Leaf node level.                       */
 
 
-#define is_leaf_block_head(buf) (le16_to_cpu (((struct block_head *)(buf))->blk_level) == DISK_LEAF_NODE_LEVEL)
+#define is_leaf_block_head(buf) (blkh_level(((struct block_head *)(buf))) == DISK_LEAF_NODE_LEVEL)
 #define is_internal_block_head(buf) \
-((le16_to_cpu (((struct block_head *)(buf))->blk_level) > DISK_LEAF_NODE_LEVEL) &&\
- (le16_to_cpu (((struct block_head *)(buf))->blk_level) <= MAX_HEIGHT))
+((blkh_level(((struct block_head *)(buf))) > DISK_LEAF_NODE_LEVEL) &&\
+ (blkh_level(((struct block_head *)(buf))) <= MAX_HEIGHT))
 
 
 /* Given the buffer head of a formatted node, resolve to the block head of that node. */
 #define B_BLK_HEAD(p_s_bh)  ((struct block_head *)((p_s_bh)->b_data))
 
 /* Number of items that are in buffer. */
-#define node_item_number(bh)	(le16_to_cpu ( B_BLK_HEAD(bh)->blk_nr_item ))
+#define node_item_number(bh)	(blkh_nr_item( B_BLK_HEAD(bh)))
 #define node_pointer_number(bh) (node_item_number(bh) + 1)
-#define node_level(bh)		(le16_to_cpu ( B_BLK_HEAD(bh)->blk_level ))
-#define node_free_space(bh)	(le16_to_cpu ( B_BLK_HEAD(bh)->blk_free_space ))
+#define node_level(bh)		(blkh_level( B_BLK_HEAD(bh)))
+#define node_free_space(bh)	(blkh_free_space( B_BLK_HEAD(bh)))
 
-#define set_node_item_number(bh,n) (B_BLK_HEAD(bh)->blk_nr_item = cpu_to_le16 (n))
-#define set_node_free_space(bh,n) (B_BLK_HEAD(bh)->blk_free_space = cpu_to_le16 (n))
-#define set_node_level(bh,n) (B_BLK_HEAD(bh)->blk_level = cpu_to_le16 (n))
-#define set_leaf_node_level(bh) set_node_level (bh, DISK_LEAF_NODE_LEVEL)
+#define set_node_item_number(bh,n) (set_blkh_nr_item(B_BLK_HEAD(bh),(n)))
+#define set_node_free_space(bh,n)  (set_blkh_free_space(B_BLK_HEAD(bh),(n)))
+#define set_node_level(bh,n)       (set_blkh_level(B_BLK_HEAD(bh), (n)))
+#define set_leaf_node_level(bh)    (set_node_level (bh, DISK_LEAF_NODE_LEVEL))
 
 #define B_NR_ITEMS(bh)		node_item_number(bh)
 #define B_LEVEL(bh)		node_level(bh)
@@ -583,7 +707,7 @@
     union {
 	__u32 sd_rdev;
 	__u32 sd_blocks;	/* number of blocks file uses */
-    } u;
+    } __attribute__ ((__packed__)) u;
     __u32 sd_first_direct_byte; /* first byte of file which is stored
 				   in a direct item: except that if it
 				   equals 1 it is a symlink and if it
@@ -628,7 +752,7 @@
 	 direct item.  The existence of this field really grates on me. Let's
 	 replace it with a macro based on sd_size and our tail suppression
 	 policy? */
-  } u;
+  } __attribute__ ((__packed__)) u;
 } __attribute__ ((__packed__));
 //
 // this is 44 bytes long
@@ -690,14 +814,18 @@
 			future), and 2) whether entry is hidden
 			(unlinked) */
 } __attribute__ ((__packed__));
-#define DEH_SIZE sizeof(struct reiserfs_de_head)
 
-
-#define deh_offset(deh) (le32_to_cpu ((deh)->deh_offset))
-#define deh_dir_id(deh) (le32_to_cpu ((deh)->deh_dir_id))
-#define deh_objectid(deh) (le32_to_cpu ((deh)->deh_objectid))
-#define deh_location(deh) (le16_to_cpu ((deh)->deh_location))
-#define deh_state(deh) (le16_to_cpu ((deh)->deh_state))
+#define DEH_SIZE                 sizeof(struct reiserfs_de_head)
+#define deh_offset(deh)          (le32_to_cpu ((deh)->deh_offset))
+#define set_deh_offset(deh,x)    ((deh)->deh_offset = cpu_to_le32((x)))
+#define deh_dir_id(deh)          (le32_to_cpu ((deh)->deh_dir_id))
+#define set_deh_dir_id(deh,x)    ((deh)->deh_dir_id = cpu_to_le32((x)))
+#define deh_objectid(deh)        (le32_to_cpu ((deh)->deh_objectid))
+#define set_deh_objectid(deh,x)  ((deh)->deh_objectid = cpu_to_le32((x)))
+#define deh_location(deh)        (le16_to_cpu ((deh)->deh_location))
+#define set_deh_location(deh,x)  ((deh)->deh_location = cpu_to_le16((x)))
+#define deh_state(deh)           (le16_to_cpu ((deh)->deh_state))
+#define set_deh_state(deh,x)     ((deh)->deh_offset = cpu_to_le16((x)))
 
 /* empty directory contains two entries "." and ".." and their headers */
 #define EMPTY_DIR_SIZE \
@@ -712,22 +840,64 @@
 #define DEH_Bad_offset 4 /* fsck marks entries to be deleted with this flag */
 #define DEH_Bad_location 5
 
-#define mark_de_with_sd(deh)        set_bit (DEH_Statdata, &((deh)->deh_state))
-#define mark_de_without_sd(deh)     clear_bit (DEH_Statdata, &((deh)->deh_state))
-#define mark_de_visible(deh)	    set_bit (DEH_Visible, &((deh)->deh_state))
-#define mark_de_hidden(deh)	    clear_bit (DEH_Visible, &((deh)->deh_state))
-#define mark_de_lost_found(deh)	    set_bit (DEH_Lost_Found, &((deh)->deh_state))
-#define unmark_de_lost_found(deh)   clear_bit (DEH_Lost_Found, &((deh)->deh_state))
-
-#define de_with_sd(deh)		    test_bit (DEH_Statdata, &((deh)->deh_state))
-#define de_visible(deh)	    	    test_bit (DEH_Visible, &((deh)->deh_state))
-#define de_hidden(deh)	    	    !test_bit (DEH_Visible, &((deh)->deh_state))
+#ifdef __alpha__
+# define ADDR_UNALIGNED_BITS  (5)
+#endif
+ 
+#ifdef ADDR_UNALIGNED_BITS
+# define aligned_address(addr)           ((void *)((long)(addr) & ~((1UL << ADDR_UNALIGNED_BITS) - 1)))
+# define unaligned_offset(addr)          (((int)((long)(addr) & ((1 << ADDR_UNALIGNED_BITS) - 1))) << 3)
+# define set_bit_unaligned(nr, addr)     set_bit((nr) + unaligned_offset(addr), aligned_address(addr))
+# define clear_bit_unaligned(nr, addr)   clear_bit((nr) + unaligned_offset(addr), aligned_address(addr))
+# define test_bit_unaligned(nr, addr)    test_bit((nr) + unaligned_offset(addr), aligned_address(addr))
+#else
+# define set_bit_unaligned(nr, addr)     set_bit(nr, addr)
+# define clear_bit_unaligned(nr, addr)   clear_bit(nr, addr)
+# define test_bit_unaligned(nr, addr)    test_bit(nr, addr)
+#endif
+
+#if 0
+extern inline void de_mark_state( struct reiserfs_de_head *deh, int bit )
+{
+    int state = deh_state(deh);
+    set_bit_unaligned( bit, &state );
+    set_deh_state( deh, state );
+}
+ 
+extern inline void de_clear_state( struct reiserfs_de_head *deh, int bit )
+{
+    int state = deh_state(deh);
+    clear_bit_unaligned( bit, &state );
+    set_deh_state( deh, state );
+}
+ 
+extern inline int de_test_state( struct reiserfs_de_head *deh, int bit )
+{
+    /* XXX JDM This must be 'int' and not __u16 - it will break */
+    int state = deh_state( deh );
+    return test_bit_unaligned( bit, &deh->deh_state );
+}
+#endif
+
+#define de_mark_state(deh,bit)  (set_bit_unaligned( bit, &((deh)->deh_state)))
+#define de_clear_state(deh,bit) (clear_bit_unaligned( bit, &((deh)->deh_state)))
+#define de_test_state(deh,bit)  (test_bit_unaligned( bit, &((deh)->deh_state)))
+
+#define mark_de_with_sd(deh)        de_mark_state( deh, DEH_Statdata )
+#define mark_de_without_sd(deh)     de_clear_state( deh, DEH_Statdata )
+#define mark_de_visible(deh)        de_mark_state( deh, DEH_Visible )
+#define mark_de_hidden(deh)         de_clear_state( deh, DEH_Visible )
+#define mark_de_lost_found(deh)	    de_mark_state( deh, DEH_Lost_Found );
+#define unmark_de_lost_found(deh)   de_clear_state( deh, DEH_Lost_Found );
+ 
+#define de_with_sd(deh)         de_test_state( deh, DEH_Statdata )
+#define de_visible(deh)         de_test_state( deh, DEH_Visible )
+#define de_hidden(deh)          (!(de_visible(deh)))
 
 /* Bad means "hashed unproperly or/and invalid location" */
 #define de_bad_location(deh) test_bit (DEH_Bad_location, &((deh)->deh_state))
 #define mark_de_bad_location(deh) set_bit (DEH_Bad_location, &((deh)->deh_state))
 #define mark_de_good_location(deh) clear_bit (DEH_Bad_location, &((deh)->deh_state))
-
 #define de_bad_offset(deh) test_bit (DEH_Bad_offset, &((deh)->deh_state))
 #define mark_de_bad_offset(deh) set_bit (DEH_Bad_offset, &((deh)->deh_state))
 
@@ -792,9 +962,13 @@
     __u32 dc_block_number;              /* Disk child's block number. */
     __u16 dc_size;		            /* Disk child's used space.   */
     __u16 dc_reserved;
-};
+} __attribute__ ((__packed__));
 
 #define DC_SIZE (sizeof(struct disk_child))
+#define dc_block_number(dc)        (le32_to_cpu((dc)->dc_block_number))
+#define set_dc_block_number(dc,v)  ((dc)->dc_block_number = cpu_to_le32((v)))
+#define dc_size(dc)                (le16_to_cpu((dc)->dc_size))
+#define set_dc_size(dc,v)          ((dc)->dc_size = cpu_to_le16((v)))
 
 /* Get disk child by buffer header and position in the tree node. */
 #define B_N_CHILD(p_s_bh,n_pos)  ((struct disk_child *)\
@@ -802,11 +976,11 @@
             * KEY_SIZE + DC_SIZE * (n_pos)))
 
 /* Get disk child number by buffer header and position in the tree node. */
-#define B_N_CHILD_NUM(p_s_bh,n_pos) (B_N_CHILD(p_s_bh,n_pos)->dc_block_number)
-#define child_block_number(bh,pos) le32_to_cpu (B_N_CHILD(bh,pos)->dc_block_number)
-#define child_block_size(bh,pos) le16_to_cpu (B_N_CHILD(bh,pos)->dc_size)
+#define B_N_CHILD_NUM(p_s_bh,n_pos) (dc_block_number(B_N_CHILD(p_s_bh,n_pos)))
+#define child_block_number(bh,pos)  (B_N_CHILD_NUM(bh,pos))
+#define set_child_block_number(bh,pos,block) (set_dc_block_number(B_N_CHILD(bh,pos), block))
+#define child_block_size(bh,pos) dc_size(B_N_CHILD(bh,pos))
 
-#define set_dc_block_number(bh,pos,block) (B_N_CHILD (bh, pos)->dc_block_number = cpu_to_le32 (block))
 
  /* maximal value of field child_size in structure disk_child */ 
  /* child size is the combined size of all items and their headers */
@@ -1237,7 +1411,7 @@
 #define not_of_one_file comp_short_keys
 
 /* number of blocks pointed to by the indirect item */
-#define I_UNFM_NUM(p_s_ih)	( (p_s_ih)->ih_item_len / UNFM_P_SIZE )
+#define I_UNFM_NUM(p_s_ih)	( ih_item_len(p_s_ih) / UNFM_P_SIZE )
 
 /* the used space within the unformatted node corresponding to pos within the item pointed to by ih */
 #define I_POS_UNFM_SIZE(ih,pos,size) (((pos) == I_UNFM_NUM(ih) - 1 ) ? (size) - ih_free_space (ih) : (size))
@@ -1257,11 +1431,11 @@
 #define B_N_PKEY(bh,item_num) ( &(B_N_PITEM_HEAD(bh,item_num)->ih_key) )
 
 /* get item body */
-#define B_N_PITEM(bh,item_num) ( (bh)->b_data + B_N_PITEM_HEAD((bh),(item_num))->ih_item_location)
+#define B_N_PITEM(bh,item_num) ( (bh)->b_data + ih_location(B_N_PITEM_HEAD((bh),(item_num))))
 
 /* get the stat data by the buffer header and the item order */
 #define B_N_STAT_DATA(bh,nr) \
-( (struct stat_data *)((bh)->b_data+B_N_PITEM_HEAD((bh),(nr))->ih_item_location ) )
+( (struct stat_data *)((bh)->b_data+ih_location(B_N_PITEM_HEAD((bh),(nr))) ) )
 
  /* following defines use reiserfs buffer header and item header */
  /* get item body */
diff -ruP -x CVS reiserfsprogs-3.x.0j/include/swab.h reiserfsprogs-devel/include/swab.h
--- reiserfsprogs-3.x.0j/include/swab.h	Wed Dec 31 19:00:00 1969
+++ reiserfsprogs-devel/include/swab.h	Mon Mar 12 17:56:01 2001
@@ -0,0 +1,25 @@
+#ifndef _REISERFS_SWAB_H_
+#define _REISERFS_SWAB_H_
+/* Stolen from linux/include/linux/byteorder/swab.h */
+#define swab16(x) \
+	((__u16)( \
+		(((__u16)(x) & (__u16)0x00ffU) << 8) | \
+		(((__u16)(x) & (__u16)0xff00U) >> 8) ))
+#define swab32(x) \
+	((__u32)( \
+		(((__u32)(x) & (__u32)0x000000ffUL) << 24) | \
+		(((__u32)(x) & (__u32)0x0000ff00UL) <<  8) | \
+		(((__u32)(x) & (__u32)0x00ff0000UL) >>  8) | \
+		(((__u32)(x) & (__u32)0xff000000UL) >> 24) ))
+#define swab64(x) \
+	((__u64)( \
+		(__u64)(((__u64)(x) & (__u64)0x00000000000000ffULL) << 56) | \
+		(__u64)(((__u64)(x) & (__u64)0x000000000000ff00ULL) << 40) | \
+		(__u64)(((__u64)(x) & (__u64)0x0000000000ff0000ULL) << 24) | \
+		(__u64)(((__u64)(x) & (__u64)0x00000000ff000000ULL) <<  8) | \
+	        (__u64)(((__u64)(x) & (__u64)0x000000ff00000000ULL) >>  8) | \
+		(__u64)(((__u64)(x) & (__u64)0x0000ff0000000000ULL) >> 24) | \
+		(__u64)(((__u64)(x) & (__u64)0x00ff000000000000ULL) >> 40) | \
+		(__u64)(((__u64)(x) & (__u64)0xff00000000000000ULL) >> 56) ))
+
+#endif /* _REISERFS_SWAB_H_ */
diff -ruP -x CVS reiserfsprogs-3.x.0j/lib/misc.c reiserfsprogs-devel/lib/misc.c
--- reiserfsprogs-3.x.0j/lib/misc.c	Sat Mar 24 10:31:47 2001
+++ reiserfsprogs-devel/lib/misc.c	Tue May  1 20:27:31 2001
@@ -17,110 +17,10 @@
 #include <fcntl.h>
 #include <sys/stat.h>
 
-#include "io.h"
-
-/*
- * These have been stolen somewhere from linux
- */
-int set_bit (int nr, void * addr)
-{
-    __u8 * p, mask;
-    int retval;
-
-    p = (__u8 *)addr;
-    p += nr >> 3;
-    mask = 1 << (nr & 0x7);
-    /*cli();*/
-    retval = (mask & *p) != 0;
-    *p |= mask;
-    /*sti();*/
-    return retval;
-}
-
-
-int clear_bit (int nr, void * addr)
-{
-    __u8 * p, mask;
-    int retval;
-
-    p = (__u8 *)addr;
-    p += nr >> 3;
-    mask = 1 << (nr & 0x7);
-    /*cli();*/
-    retval = (mask & *p) != 0;
-    *p &= ~mask;
-    /*sti();*/
-    return retval;
-}
-
-int test_bit(int nr, const void * addr)
-{
-    __u8 * p, mask;
-  
-    p = (__u8 *)addr;
-    p += nr >> 3;
-    mask = 1 << (nr & 0x7);
-    return ((mask & *p) != 0);
-}
-
-int find_first_zero_bit (const void *vaddr, unsigned size)
-{
-    const __u8 *p = vaddr, *addr = vaddr;
-    int res;
-
-    if (!size)
-	return 0;
-
-    size = (size >> 3) + ((size & 0x7) > 0);
-    while (*p++ == 255) {
-	if (--size == 0)
-	    return (p - addr) << 3;
-    }
-  
-    --p;
-    for (res = 0; res < 8; res++)
-	if (!test_bit (res, p))
-	    break;
-    return (p - addr) * 8 + res;
-}
-
-
-int find_next_zero_bit (const void *vaddr, unsigned size, unsigned offset)
-{
-    const __u8 *addr = vaddr;
-    const __u8 *p = addr + (offset >> 3);
-    int bit = offset & 7, res;
-  
-    if (offset >= size)
-	return size;
-  
-    if (bit) {
-	/* Look for zero in first char */
-	for (res = bit; res < 8; res++)
-	    if (!test_bit (res, p))
-		return (p - addr) * 8 + res;
-	p++;
-    }
-    /* No zero yet, search remaining full bytes for a zero */
-    res = find_first_zero_bit (p, size - 8 * (p - addr));
-    return (p - addr) * 8 + res;
-}
-
-
-/*int test_and_set_bit (int nr, void * addr)
-{
-  int oldbit = test_bit (nr, addr);
-  set_bit (nr, addr);
-  return oldbit;
-}
+#include "swab.h"
 
+#include "io.h"
 
-int test_and_clear_bit (int nr, void * addr)
-{
-  int oldbit = test_bit (nr, addr);
-  clear_bit (nr, addr);
-  return oldbit;
-}*/
 
 
 void die (char * fmt, ...)
@@ -446,15 +346,12 @@
     fflush (stderr);
 }
 
-
-
 #define ENDIANESS_NOT_DEFINED 0
 #define LITTLE_ENDIAN_ARCH 1
 #define BIG_ENDIAN_ARCH 2
 
 static int endianess = ENDIANESS_NOT_DEFINED;
 
-
 static void find_endianess (void)
 {
     __u32 x = 0x0f0d0b09;
@@ -468,7 +365,7 @@
 
     // big-endian is 4321
     if (s[0] == '\17' && s[1] == '\15' && s[2] == '\13' && s[3] == '\11')
-	die ("big-endian archs are not supported");
+	endianess = BIG_ENDIAN_ARCH;
 
     // nuxi/pdp-endian is 3412
     if (s[0] == '\15' && s[1] == '\17' && s[2] == '\11' && s[3] == '\13')
@@ -486,7 +383,10 @@
     if (endianess == LITTLE_ENDIAN_ARCH)
 	return val;
 
-    die ("neither big- nor any other endian archs are supported yet ");
+    if (endianess == BIG_ENDIAN_ARCH)
+        return swab32(val);
+
+    die ("nuxi/pdp-endian archs are not supported");
 
     return ((val>>24) | ((val>>8)&0xFF00) |
 	    ((val<<8)&0xFF0000) | (val<<24));
@@ -501,26 +401,22 @@
 
 inline __u16 cpu_to_le16 (__u16 val)
 {
-    return val;
-
     if (endianess == ENDIANESS_NOT_DEFINED)
 	find_endianess ();
 
     if (endianess == LITTLE_ENDIAN_ARCH)
 	return val;
-    die ("neither big- nor pdp- endian arch are supported yet ");
 
-    return (val >> 8) | (val << 8);
+    if (endianess == BIG_ENDIAN_ARCH)
+        return swab16(val);
+
+    die ("nuxi/pdp-endian archs are not supported");
+    return 0;
 }
 
 
 inline __u16 le16_to_cpu (__u16 val)
 {
-    /*printf ("%s:%u %p %p %p\n", __FILE__, __LINE__,
-	    __builtin_return_address (0),
-	    __builtin_return_address (1),
-	    __builtin_return_address (2));*/
-    return val;
     return cpu_to_le16 (val);
 }
 
@@ -532,8 +428,10 @@
 
     if (endianess == LITTLE_ENDIAN_ARCH)
 	return val;
-    die ("neither big- nor pdp- endian arch are supported yet ");
-
+    if (endianess == BIG_ENDIAN_ARCH)
+        return swab64(val);
+    
+    die ("nuxi/pdp-endian archs are not supported");
     return 0;
 }
 
@@ -611,3 +509,249 @@
 
 
 
+/*
+ * These have been stolen somewhere from linux
+ */
+static int le_set_bit (int nr, void * addr)
+{
+    __u8 * p, mask;
+    int retval;
+
+    p = (__u8 *)addr;
+    p += nr >> 3;
+    mask = 1 << (nr & 0x7);
+    /*cli();*/
+    retval = (mask & *p) != 0;
+    *p |= mask;
+    /*sti();*/
+    return retval;
+}
+
+
+static int le_clear_bit (int nr, void * addr)
+{
+    __u8 * p, mask;
+    int retval;
+
+    p = (__u8 *)addr;
+    p += nr >> 3;
+    mask = 1 << (nr & 0x7);
+    /*cli();*/
+    retval = (mask & *p) != 0;
+    *p &= ~mask;
+    /*sti();*/
+    return retval;
+}
+
+static int le_test_bit(int nr, const void * addr)
+{
+    __u8 * p, mask;
+  
+    p = (__u8 *)addr;
+    p += nr >> 3;
+    mask = 1 << (nr & 0x7);
+    return ((mask & *p) != 0);
+}
+
+static int le_find_first_zero_bit (const void *vaddr, unsigned size)
+{
+    const __u8 *p = vaddr, *addr = vaddr;
+    int res;
+
+    if (!size)
+	return 0;
+
+    size = (size >> 3) + ((size & 0x7) > 0);
+    while (*p++ == 255) {
+	if (--size == 0)
+	    return (p - addr) << 3;
+    }
+  
+    --p;
+    for (res = 0; res < 8; res++)
+	if (!test_bit (res, p))
+	    break;
+    return (p - addr) * 8 + res;
+}
+
+
+static int le_find_next_zero_bit (const void *vaddr, unsigned size, unsigned offset)
+{
+    const __u8 *addr = vaddr;
+    const __u8 *p = addr + (offset >> 3);
+    int bit = offset & 7, res;
+  
+    if (offset >= size)
+	return size;
+  
+    if (bit) {
+	/* Look for zero in first char */
+	for (res = bit; res < 8; res++)
+	    if (!test_bit (res, p))
+		return (p - addr) * 8 + res;
+	p++;
+    }
+    /* No zero yet, search remaining full bytes for a zero */
+    res = find_first_zero_bit (p, size - 8 * (p - addr));
+    return (p - addr) * 8 + res;
+}
+
+static int be_set_bit (int nr, void * addr)
+{
+    int             mask;
+    __u8   *ADDR = (unsigned char *) addr;
+    int oldbit;
+ 
+    ADDR += nr >> 3;
+    mask = 1 << (nr & 0x07);
+    oldbit = (*ADDR & mask) ? 1 : 0;
+    *ADDR |= mask;
+    return oldbit;
+}
+ 
+static int be_clear_bit (int nr, void * addr)
+{
+    int             mask;
+    __u8   *ADDR = (unsigned char *) addr;
+    int oldbit;
+ 
+    ADDR += nr >> 3;
+    mask = 1 << (nr & 0x07);
+    oldbit = (*ADDR & mask) ? 1 : 0;
+    *ADDR = *ADDR & ~mask;
+    return oldbit;
+}
+ 
+static int be_test_bit(int nr, const void * addr)
+{
+    const __u8 *ADDR = (__const__ unsigned char *) addr;
+ 
+    return (ADDR[nr >> 3] >> (nr & 7)) & 1;
+}
+ 
+static int be_find_first_zero_bit (const void *vaddr, unsigned size)
+{
+    return find_next_zero_bit( vaddr, size, 0 );
+}
+
+extern __inline__ unsigned long ffz(unsigned long word)
+{
+        unsigned long result = 0;
+ 
+        while(word & 1) {
+                result++;
+                word >>= 1;
+        }
+        return result;
+}
+
+static int be_find_next_zero_bit (const void *vaddr, unsigned size, unsigned offset)
+{
+    unsigned long *p = ((unsigned long *) vaddr) + (offset >> 5);
+    unsigned long result = offset & ~31UL;
+    unsigned long tmp;
+
+    if (offset >= size)
+        return size;
+    size -= result;
+    offset &= 31UL;
+    if (offset) {
+        tmp = *(p++);
+        tmp |= ~0UL >> (32-offset);
+        if (size < 32)
+            goto found_first;
+        if (~tmp)
+            goto found_middle;
+        size -= 32;
+        result += 32;
+    }
+    while (size & ~31UL) {
+        if (~(tmp = *(p++)))
+            goto found_middle;
+        result += 32;
+        size -= 32;
+    }
+    if (!size)
+        return result;
+    tmp = *p;
+
+found_first:
+    tmp |= ~0UL << size;
+found_middle:
+    return result + ffz(tmp);
+}
+
+inline int set_bit (int nr, void * addr)
+{
+    if (endianess == ENDIANESS_NOT_DEFINED)
+        find_endianess ();
+ 
+    if (endianess == LITTLE_ENDIAN_ARCH)
+        return le_set_bit( nr, addr );
+ 
+    if (endianess == BIG_ENDIAN_ARCH)
+        return be_set_bit( nr, addr );
+ 
+    die ("nuxi/pdp-endian archs are not supported");
+    return 0;
+}
+
+inline int clear_bit (int nr, void * addr)
+{
+    if (endianess == ENDIANESS_NOT_DEFINED)
+        find_endianess ();
+ 
+    if (endianess == LITTLE_ENDIAN_ARCH)
+        return le_clear_bit( nr, addr );
+ 
+    if (endianess == BIG_ENDIAN_ARCH)
+        return be_clear_bit( nr, addr );
+ 
+    die ("nuxi/pdp-endian archs are not supported");
+    return 0;
+}
+
+int test_bit(int nr, const void * addr)
+{
+    if (endianess == ENDIANESS_NOT_DEFINED)
+        find_endianess ();
+ 
+    if (endianess == LITTLE_ENDIAN_ARCH)
+        return le_test_bit( nr, addr );
+ 
+    if (endianess == BIG_ENDIAN_ARCH)
+        return be_test_bit( nr, addr );
+ 
+    die ("nuxi/pdp-endian archs are not supported");
+    return 0;
+}
+
+int find_first_zero_bit (const void *vaddr, unsigned size)
+{
+    if (endianess == ENDIANESS_NOT_DEFINED)
+        find_endianess ();
+ 
+    if (endianess == LITTLE_ENDIAN_ARCH)
+        return le_find_first_zero_bit( vaddr, size );
+ 
+    if (endianess == BIG_ENDIAN_ARCH)
+        return be_find_first_zero_bit( vaddr, size );
+ 
+    die ("nuxi/pdp-endian archs are not supported");
+    return 0;
+}
+
+int find_next_zero_bit (const void *vaddr, unsigned size, unsigned offset)
+{
+    if (endianess == ENDIANESS_NOT_DEFINED)
+        find_endianess ();
+ 
+    if (endianess == LITTLE_ENDIAN_ARCH)
+        return le_find_next_zero_bit( vaddr, size, offset );
+ 
+    if (endianess == BIG_ENDIAN_ARCH)
+        return be_find_next_zero_bit( vaddr, size, offset );
+ 
+    die ("nuxi/pdp-endian archs are not supported");
+    return 0;
+}
diff -ruP -x CVS reiserfsprogs-3.x.0j/mkreiserfs/mkreiserfs.c reiserfsprogs-devel/mkreiserfs/mkreiserfs.c
--- reiserfsprogs-3.x.0j/mkreiserfs/mkreiserfs.c	Sat Mar 24 10:18:32 2001
+++ reiserfsprogs-devel/mkreiserfs/mkreiserfs.c	Tue May  1 20:27:31 2001
@@ -229,18 +229,20 @@
     ih->ih_key.k_objectid = cpu_to_le32 (REISERFS_ROOT_OBJECTID);
     ih->ih_key.u.k_offset_v1.k_offset = cpu_to_le32 (DOT_OFFSET);
     ih->ih_key.u.k_offset_v1.k_uniqueness = cpu_to_le32 (DIRENTRY_UNIQUENESS);
-    ih->ih_item_len = cpu_to_le16 (g_3_6_format ? EMPTY_DIR_SIZE : EMPTY_DIR_SIZE_V1);
-    ih->ih_item_location = cpu_to_le16 (ih_location (ih-1) - ih_item_len (ih));
-    ih->u.ih_entry_count = cpu_to_le16 (2);
-    set_key_format (ih, KEY_FORMAT_1);
+    set_ih_item_len( ih, (g_3_6_format ? EMPTY_DIR_SIZE : EMPTY_DIR_SIZE_V1 ));
+    set_ih_location(ih, (ih_location(ih-1) - ih_item_len(ih) ) );
+    set_entry_count(ih,2);
+    set_ih_key_format (ih, KEY_FORMAT_1);
 
     if (g_3_6_format)
 	make_empty_dir_item (g_rb_bh->b_data + ih_location (ih),
-			     REISERFS_ROOT_PARENT_OBJECTID, REISERFS_ROOT_OBJECTID,
+			     REISERFS_ROOT_PARENT_OBJECTID,
+                             REISERFS_ROOT_OBJECTID,
 			     0, REISERFS_ROOT_PARENT_OBJECTID);
     else
 	make_empty_dir_item_v1 (g_rb_bh->b_data + ih_location (ih),
-				REISERFS_ROOT_PARENT_OBJECTID, REISERFS_ROOT_OBJECTID,
+				REISERFS_ROOT_PARENT_OBJECTID,
+                                REISERFS_ROOT_OBJECTID,
 				0, REISERFS_ROOT_PARENT_OBJECTID);
 
     // adjust block head
@@ -380,7 +382,7 @@
     int force = 0;
     struct stat st;
     char * device_name;
-    char c;
+    int c;
 
     print_banner ("mkreiserfs");
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/do_balan.c reiserfsprogs-devel/reiserfscore/do_balan.c
--- reiserfsprogs-3.x.0j/reiserfscore/do_balan.c	Wed Mar 28 09:39:30 2001
+++ reiserfsprogs-devel/reiserfscore/do_balan.c	Tue May  1 20:27:31 2001
@@ -75,9 +75,10 @@
     struct item_head * ih;
 
 #ifdef CONFIG_REISERFS_CHECK
-    if ( tb->FR[0] && B_BLK_HEAD(tb->FR[0])->blk_level <= DISK_LEAF_NODE_LEVEL )
+    if ( tb->FR[0] && blkh_level(B_BLK_HEAD(tb->FR[0])) <= DISK_LEAF_NODE_LEVEL )
 	reiserfs_panic (tb->tb_sb,
-			"balance_leaf_when_delete: 11999:level == %u\n", B_BLK_HEAD(tb->FR[0])->blk_level);
+			"balance_leaf_when_delete: 11999:level == %u\n",
+                        blkh_level(B_BLK_HEAD(tb->FR[0])));
     if ( tb->blknum[0] > 1 )
 	reiserfs_panic (tb->tb_sb,
 			"PAP-12005: balance_leaf_when_delete: tb->blknum == %d, can not be > 1", tb->blknum[0]);
@@ -141,7 +142,7 @@
 	    leaf_cut_from_buffer (tb->tb_sb, &bi, item_pos, pos_in_item, -tb->insert_size[0]);
 
 #ifdef CONFIG_REISERFS_CHECK
-	    if (! ih->ih_item_len)
+	    if (! ih_item_len(ih))
 		reiserfs_panic (tb->tb_sb, "PAP-12035: balance_leaf_when_delete: cut must leave non-zero dynamic length of item");
 #endif /* CONFIG_REISERFS_CHECK */
 	}
@@ -307,15 +308,15 @@
 		    ret_val = leaf_shift_left (/*th,*/ tb, tb->lnum[0]-1, -1);
 
 		    /* Calculate item length to insert to S[0] */
-		    new_item_len = ih->ih_item_len - tb->lbytes;
+		    new_item_len = ih_item_len(ih) - tb->lbytes;
 		    /* Calculate and check item length to insert to L[0] */
-		    ih->ih_item_len -= new_item_len;
+                    set_ih_item_len(ih, ih_item_len(ih) - new_item_len );
 
 #ifdef CONFIG_REISERFS_CHECK
-		    if ( (int)(ih->ih_item_len) <= 0 )
+		    if ( (int)(ih_item_len(ih)) <= 0 )
 			reiserfs_panic(tb->tb_sb, "PAP-12080: balance_leaf: "
 				       "there is nothing to insert into L[0]: ih_item_len=%d",
-				       (int)ih->ih_item_len);
+				       (int)ih_item_len(ih));
 #endif
 
 		    /* Insert new item into L[0] */
@@ -323,12 +324,13 @@
 		    bi.bi_parent = tb->FL[0];
 		    bi.bi_position = get_left_neighbor_position (tb, 0);
 		    leaf_insert_into_buf (tb->tb_sb, &bi, n + item_pos - ret_val, ih, body,
-					  zeros_number > ih->ih_item_len ? ih->ih_item_len : zeros_number);
+					  zeros_number > ih_item_len(ih) ?
+                                          ih_item_len(ih) : zeros_number);
 
 		    /* Calculate key component, item length and body to insert into S[0] */
 		    //ih->ih_key.k_offset += tb->lbytes;
 		    set_offset (key_format (&ih->ih_key), &ih->ih_key, get_offset (&ih->ih_key) + tb->lbytes);
-		    ih->ih_item_len = new_item_len;
+                    set_ih_item_len(ih, new_item_len);
 		    if ( tb->lbytes >  zeros_number ) {
 			body += (tb->lbytes - zeros_number);
 			zeros_number = 0;
@@ -337,10 +339,10 @@
 			zeros_number -= tb->lbytes;
 
 #ifdef CONFIG_REISERFS_CHECK
-		    if ( (int)(ih->ih_item_len) <= 0 )
+		    if ( (int)(ih_item_len(ih)) <= 0 )
 			reiserfs_panic(tb->tb_sb, "PAP-12085: balance_leaf: "
 				       "there is nothing to insert into S[0]: ih_item_len=%d",
-				       (int)ih->ih_item_len);
+				       (int)ih_item_len(ih));
 #endif
 		} else {
 		    /* new item in whole falls into L[0] */
@@ -415,10 +417,10 @@
 			    reiserfs_panic(tb->tb_sb, "PAP-12095: balance_leaf: " 
 					   "there is nothing to shift to L[0]. lbytes=%d",
 					   tb->lbytes);
-			if ( pos_in_item != B_N_PITEM_HEAD(tbS0, item_pos)->ih_item_len )
+			if ( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)) )
 			    reiserfs_panic(tb->tb_sb, "PAP-12100: balance_leaf: " 
 					   "incorrect position to paste: item_len=%d, pos_in_item=%d",
-					   B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len, pos_in_item);
+					   ih_item_len( B_N_PITEM_HEAD(tbS0,item_pos)), pos_in_item);
 #endif
 
 			if ( tb->lbytes >= pos_in_item ) {
@@ -440,14 +442,14 @@
 #endif
 
 			    ret_val =  leaf_shift_left(tb, tb->lnum[0], 
-						       B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len);
+						       ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)));
 			    /* Append to body of item in L[0] */
 			    bi.bi_bh = tb->L[0];
 			    bi.bi_parent = tb->FL[0];
 			    bi.bi_position = get_left_neighbor_position (tb, 0);
 			    leaf_paste_in_buffer(tb->tb_sb, 
 						 &bi,n + item_pos - ret_val,
-						 B_N_PITEM_HEAD(tb->L[0],n+item_pos-ret_val)->ih_item_len,
+						 ih_item_len(B_N_PITEM_HEAD(tb->L[0],n+item_pos-ret_val)),
 						 l_n,body, zeros_number > l_n ? l_n : zeros_number
 				);
 
@@ -518,7 +520,7 @@
 			    if ( I_IS_DIRECTORY_ITEM(pasted) )
 				pos_in_item += ih_entry_count (pasted);
 			    else
-				pos_in_item += pasted->ih_item_len;
+				pos_in_item += ih_item_len(pasted);
 			}
 
 		    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
@@ -581,13 +583,13 @@
 
 		    /* Remember key component and item length */
 		    old_key_comp = get_offset (&ih->ih_key);
-		    old_len = ih->ih_item_len;
+		    old_len = ih_item_len(ih);
 
 		    /* Calculate key component and item length to insert into R[0] */
 		    //ih->ih_key.k_offset += (old_len - tb->rbytes);
 		    set_offset (key_format (&ih->ih_key), &ih->ih_key, old_key_comp + old_len - tb->rbytes);
 
-		    ih->ih_item_len = tb->rbytes;
+                    set_ih_item_len(ih, tb->rbytes);
 		    /* Insert part of the item into R[0] */
 		    bi.bi_bh = tb->R[0];
 		    bi.bi_parent = tb->FR[0];
@@ -611,7 +613,7 @@
 		    //ih->ih_key.k_offset = old_key_comp;
 		    set_offset (key_format (&ih->ih_key), &ih->ih_key, old_key_comp);
 
-		    ih->ih_item_len = old_len - tb->rbytes;
+                    set_ih_item_len(ih, old_len - tb->rbytes );
 
 		    tb->insert_size[0] -= tb->rbytes;
 
@@ -707,7 +709,7 @@
 			    n_shift = 0;
 
 #ifdef CONFIG_REISERFS_CHECK
-			if (pos_in_item != B_N_PITEM_HEAD (tbS0, item_pos)->ih_item_len)
+			if (pos_in_item != ih_item_len(B_N_PITEM_HEAD (tbS0, item_pos)))
 			    reiserfs_panic(tb->tb_sb,"PAP-12155: balance_leaf: invalid position %d to paste item %h",
 					   pos_in_item, B_N_PITEM_HEAD(tbS0,item_pos));
 #endif
@@ -896,13 +898,13 @@
 
 		    /* Remember key component and item length */
 		    old_key_comp = get_offset (&ih->ih_key);
-		    old_len = ih->ih_item_len;
+		    old_len = ih_item_len(ih);
 
 		    /* Calculate key component and item length to insert into S_new[i] */
 		    //ih->ih_key.k_offset += (old_len - sbytes[i]);
 		    set_offset (key_format (&ih->ih_key), &ih->ih_key, old_key_comp + old_len - sbytes[i]);
 
-		    ih->ih_item_len = sbytes[i];
+                    set_ih_item_len(ih, sbytes[i]);
 
 		    /* Insert part of the item into S_new[i] before 0-th item */
 		    bi.bi_bh = S_new[i];
@@ -924,7 +926,7 @@
 		    /* Calculate key component and item length to insert into S[i] */
 		    //ih->ih_key.k_offset = old_key_comp;
 		    set_offset (key_format (&ih->ih_key), &ih->ih_key, old_key_comp);
-		    ih->ih_item_len = old_len - sbytes[i];
+                    set_ih_item_len(ih, old_len - sbytes[i]);
 		    tb->insert_size[0] -= sbytes[i];
 		}
 		else /* whole new item falls into S_new[i] */
@@ -1007,7 +1009,7 @@
 			struct item_head * tmp;
 
 #ifdef CONFIG_REISERFS_CHECK
-			if ( pos_in_item != B_N_PITEM_HEAD(tbS0,item_pos)->ih_item_len ||
+			if ( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)) ||
 			     tb->insert_size[0] <= 0 )
 			    reiserfs_panic (tb->tb_sb, "PAP-12225: balance_leaf: item too short or insert_size <= 0");
 #endif
@@ -1064,7 +1066,7 @@
 #ifdef CONFIG_REISERFS_CHECK
 		    struct item_head * ih = B_N_PITEM_HEAD(tbS0,item_pos);
 
-		    if ( ! I_IS_DIRECTORY_ITEM(ih) && (pos_in_item != ih->ih_item_len ||
+		    if ( ! I_IS_DIRECTORY_ITEM(ih) && (pos_in_item != ih_item_len(ih) ||
 						       tb->insert_size[0] <= 0) )
 			reiserfs_panic (tb->tb_sb, "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
 #endif /* CONFIG_REISERFS_CHECK */
@@ -1179,7 +1181,7 @@
 		    tb->insert_size[0] = 0;
 		}
 	    } else { /* regular object */
-		if ( pos_in_item == pasted->ih_item_len ) {
+		if ( pos_in_item == ih_item_len(pasted) ) {
 
 #ifdef CONFIG_REISERFS_CHECK
 		    if ( tb->insert_size[0] <= 0 )
@@ -1245,11 +1247,12 @@
 	reiserfs_panic (0, "PAP-12295: make_empty_node: pointer to the buffer is NULL");
 #endif
 
-    (blkh = B_BLK_HEAD(bi->bi_bh))->blk_nr_item = 0;
-    blkh->blk_free_space = MAX_CHILD_SIZE(bi->bi_bh); 
+    blkh = B_BLK_HEAD(bi->bi_bh);
+    blkh->blk_nr_item = 0; /* Safe if 0 */
+    set_blkh_free_space(blkh, MAX_CHILD_SIZE(bi->bi_bh));
 
     if (bi->bi_parent)
-	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size = 0; 
+	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size = 0; /* Safe if 0 */
 }
 
 
@@ -1292,7 +1295,7 @@
 
     if ( ! B_IS_KEYS_LEVEL (dest) )
 	reiserfs_panic (0, "vs-12310: replace_key: invalid level (%d) for destination buffer. Must be > %d",
-			B_BLK_HEAD(dest)->blk_level, DISK_LEAF_NODE_LEVEL);
+			blkh_level(B_BLK_HEAD(dest)), DISK_LEAF_NODE_LEVEL);
 
     if (n_dest < 0 || n_src < 0)
 	reiserfs_panic (0, "vs-12315: replace_key: src(%d) or dest(%d) key number less than 0", n_src, n_dest);
@@ -1317,7 +1320,7 @@
 void reiserfs_invalidate_buffer (struct tree_balance * tb, struct buffer_head * bh, int do_free_block)
 {
 
-    B_BLK_HEAD (bh)->blk_level = FREE_LEVEL;
+    set_blkh_level( B_BLK_HEAD(bh), FREE_LEVEL );
     clear_bit(BH_Dirty, &bh->b_state);
 
 #ifdef CONFIG_REISERFS_CHECK
@@ -1397,11 +1400,11 @@
     dc = B_N_CHILD (bh, 0);
 
     for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
-	if (!is_reusable (s, dc->dc_block_number, 1) ) {
+	if (!is_reusable (s, dc_block_number(dc), 1) ) {
 	    print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, mes);
 	    reiserfs_panic (s, "PAP-12338: check_internal_node: invalid child pointer %y in %b", dc, bh);
 	}
-	if (dc->dc_size <= BLKH_SIZE) {
+	if (dc_size(dc) <= BLKH_SIZE) {
 	    print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, mes);
 	    reiserfs_panic (s, "PAP-12338: check_internal_node: empty node in the tree? %y", dc);
 	}
@@ -1474,24 +1477,27 @@
 static void check_after_balance_leaf (struct tree_balance * tb)
 {
     if (tb->lnum[0]) {
-	if (B_BLK_HEAD (tb->L[0])->blk_free_space != 
-	    MAX_CHILD_SIZE (tb->L[0]) - B_N_CHILD (tb->FL[0], get_left_neighbor_position (tb, 0))->dc_size) {
+	if (blkh_free_space(B_BLK_HEAD (tb->L[0])) != 
+	    MAX_CHILD_SIZE (tb->L[0]) -
+            dc_size(B_N_CHILD(tb->FL[0], get_left_neighbor_position (tb, 0)))) {
 	    print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12221");
 	    reiserfs_panic (tb->tb_sb, "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
 	}
     }
     if (tb->rnum[0]) {
-	if (B_BLK_HEAD (tb->R[0])->blk_free_space != 
-	    MAX_CHILD_SIZE (tb->R[0]) - B_N_CHILD (tb->FR[0], get_right_neighbor_position (tb, 0))->dc_size) {
+	if (blkh_free_space(B_BLK_HEAD (tb->R[0])) != 
+	    MAX_CHILD_SIZE (tb->R[0]) -
+            dc_size(B_N_CHILD (tb->FR[0], get_right_neighbor_position (tb, 0))))
+        {
 	    print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12222");
 	    reiserfs_panic (tb->tb_sb, "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
 	}
     }
     if (PATH_H_PBUFFER(tb->tb_path,1) && 
-	B_BLK_HEAD (PATH_H_PBUFFER(tb->tb_path,0))->blk_free_space != 
+	blkh_free_space(B_BLK_HEAD (PATH_H_PBUFFER(tb->tb_path,0))) != 
 	MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
-	B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1), 
-		   PATH_H_POSITION (tb->tb_path, 1))->dc_size) {
+	dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1), 
+		   PATH_H_POSITION (tb->tb_path, 1)))) {
 	print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "12223");
 	reiserfs_panic (tb->tb_sb, "PAP-12365: check_after_balance_leaf: S is incorrect");
     }
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/fix_node.c reiserfsprogs-devel/reiserfscore/fix_node.c
--- reiserfsprogs-3.x.0j/reiserfscore/fix_node.c	Tue Mar  6 11:54:37 2001
+++ reiserfsprogs-devel/reiserfscore/fix_node.c	Mon Mar 26 18:35:20 2001
@@ -203,7 +203,7 @@
     temp_ih = B_N_PITEM_HEAD (PATH_PLAST_BUFFER (tb->tb_path), B_NR_ITEMS (PATH_PLAST_BUFFER (tb->tb_path)) - 1);
 
     /* size of changed node */
-    vn->vn_size = MAX_CHILD_SIZE (Sh) - B_BLK_HEAD (Sh)->blk_free_space + tb->insert_size[h];
+    vn->vn_size = MAX_CHILD_SIZE (Sh) - blkh_free_space(B_BLK_HEAD (Sh)) + tb->insert_size[h];
 
     /* for internal nodes array if virtual items is not created */
     if (h) {
@@ -264,7 +264,7 @@
 	if (I_IS_DIRECTORY_ITEM (ih + j)) {
 	    set_entry_sizes (tb, j, new_num, Sh, ih + j);
 	    vn->vn_vi[new_num].vi_type |= VI_TYPE_DIRECTORY;
-	    if (ih[j].ih_key.u.k_offset_v1.k_offset == DOT_OFFSET)
+	    if (le32_to_cpu(ih[j].ih_key.u.k_offset_v1.k_offset) == DOT_OFFSET)
 		vn->vn_vi[new_num].vi_type |= VI_TYPE_FIRST_DIRECTORY_ITEM;
 	}
     
@@ -1029,7 +1029,7 @@
 	return (get_offset (&ih->ih_key) != 1);
 
     if (I_IS_DIRECTORY_ITEM (ih))
-	return ((ih)->ih_key.u.k_offset_v1.k_offset != DOT_OFFSET);
+	return (le32_to_cpu((ih)->ih_key.u.k_offset_v1.k_offset) != DOT_OFFSET);
 
 #ifdef CONFIG_REISERFS_CHECK
     if ( ! I_IS_STAT_DATA_ITEM (ih))
@@ -1450,15 +1450,15 @@
     if (f == l)
 	order = PATH_H_B_ITEM_ORDER (tb->tb_path, h) - 1;
     else {
-	order = B_BLK_HEAD(l)->blk_nr_item;
+	order = blkh_nr_item(B_BLK_HEAD(l));
 	f = l;
     }
 
-    if (B_N_CHILD(f,order)->dc_size == 0) {
+    if ( dc_size(B_N_CHILD(f,order)) == 0) {
 	reiserfs_warning (stderr, "get_lfree: block %u block_head %z has bad child pointer %y, order %d\n",
 			  l->b_blocknr, l, B_N_CHILD(f,order), order);
     }
-    return (MAX_CHILD_SIZE(f) - B_N_CHILD(f,order)->dc_size);
+    return (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f,order)));
 }
 
 
@@ -1480,7 +1480,7 @@
       f = r;
   }
 
-  return (MAX_CHILD_SIZE(f) - B_N_CHILD(f,order)->dc_size);
+  return (MAX_CHILD_SIZE(f) - dc_size(B_N_CHILD(f,order)));
 
 }
 
@@ -1512,7 +1512,7 @@
 
   /* Get position of the pointer to the left neighbor into the left father. */
   n_left_neighbor_position = ( p_s_father == p_s_tb->FL[n_h] ) ?
-                      p_s_tb->lkey[n_h] : B_BLK_HEAD(p_s_tb->FL[n_h])->blk_nr_item;
+                      p_s_tb->lkey[n_h] : blkh_nr_item(B_BLK_HEAD(p_s_tb->FL[n_h]));
   /* Get left neighbor block number. */
   n_left_neighbor_blocknr = B_N_CHILD_NUM(p_s_tb->FL[n_h], n_left_neighbor_position);
   /* Look for the left neighbor in the cache. */
@@ -1593,7 +1593,7 @@
       return PATH_INCORRECT;
     /* Return delimiting key if position in the parent is not equal to first/last one. */
     if ( c_lr_par == RIGHT_PARENTS )
-      n_first_last_position = B_BLK_HEAD(p_s_parent)->blk_nr_item;
+      n_first_last_position = blkh_nr_item(B_BLK_HEAD(p_s_parent));
     if ( n_position != n_first_last_position ) {
       (*pp_s_com_father = p_s_parent)->b_count++;
       break;
@@ -1612,7 +1612,7 @@
   }
 
 #ifdef CONFIG_REISERFS_CHECK
-  if ( B_BLK_HEAD(*pp_s_com_father)->blk_level <= DISK_LEAF_NODE_LEVEL ) {
+  if ( blkh_level(B_BLK_HEAD(*pp_s_com_father)) <= DISK_LEAF_NODE_LEVEL ) {
     reiserfs_panic(p_s_tb->tb_sb, "PAP-8185: get_far_parent: (%b %z) level too small", *pp_s_com_father, *pp_s_com_father);
   }
 #endif
@@ -1654,7 +1654,7 @@
   *pp_s_father = PATH_PLAST_BUFFER(&s_path_to_neighbor_father);
 
 #ifdef CONFIG_REISERFS_CHECK
-  if ( B_BLK_HEAD(*pp_s_father)->blk_level != n_h + 1 ) {
+  if ( blkh_level(B_BLK_HEAD(*pp_s_father)) != n_h + 1 ) {
     reiserfs_panic(p_s_tb->tb_sb, "PAP-8190: get_far_parent: (%b %z) level too small", *pp_s_father, *pp_s_father);
   }
   
@@ -1740,7 +1740,7 @@
 /* Get parent FR[n_h] of R[n_h]. */
 
 /* Current node is the last child of F[n_h]. FR[n_h] != F[n_h]. */
-    if ( n_position == B_BLK_HEAD(PATH_H_PBUFFER(p_s_path, n_h + 1))->blk_nr_item ) {
+    if ( n_position == blkh_nr_item(B_BLK_HEAD(PATH_H_PBUFFER(p_s_path, n_h + 1))) ) {
 /* Calculate current parent of R[n_h], which is the right neighbor of F[n_h].
    Calculate current common parent of R[n_h] and current node. Note that CFR[n_h]
    not equal FR[n_path_offset] and CFR[n_h] not equal F[n_h]. */
@@ -1894,7 +1894,7 @@
   if ( (n_ret_value = get_parents (tb, h)) != CARRY_ON ) /* get parents of S[h] neighbors. */
     return n_ret_value;
   
-     sfree = B_BLK_HEAD(Sh)->blk_free_space;
+     sfree = blkh_free_space(B_BLK_HEAD(Sh));
 
      /* get free space of neighbors */
      rfree = get_rfree (tb, h);
@@ -2223,7 +2223,7 @@
 	      int order_L;
 	      
 	      order_L = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;
-	      n = B_N_CHILD(tb->FL[h],order_L)->dc_size / (DC_SIZE + KEY_SIZE);
+	      n = dc_size(B_N_CHILD(tb->FL[h],order_L)) / (DC_SIZE + KEY_SIZE);
 	      set_parameters (tb, h, -n-1, 0, 0, NULL, -1, -1);
 	      return CARRY_ON;
 	    }
@@ -2235,7 +2235,7 @@
 	      int order_R;
 	    
 	      order_R = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==B_NR_ITEMS(Fh)) ? 0 : n + 1;
-	      n = B_N_CHILD(tb->FR[h],order_R)->dc_size / (DC_SIZE + KEY_SIZE);
+	      n = dc_size(B_N_CHILD(tb->FR[h],order_R)) / (DC_SIZE + KEY_SIZE);
 	      set_parameters (tb, h, 0, -n-1, 0, NULL, -1, -1);
 	      return CARRY_ON;   
 	    }
@@ -2266,7 +2266,7 @@
 	int order_L;
 	      
 	order_L = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==0) ? B_NR_ITEMS(tb->FL[h]) : n - 1;
-	n = B_N_CHILD(tb->FL[h],order_L)->dc_size / (DC_SIZE + KEY_SIZE);
+	n = dc_size(B_N_CHILD(tb->FL[h],order_L)) / (DC_SIZE + KEY_SIZE);
 	set_parameters (tb, h, -n-1, 0, 0, NULL, -1, -1);
 	return CARRY_ON;
       }
@@ -2278,7 +2278,7 @@
       int order_R;
 	    
       order_R = ((n=PATH_H_B_ITEM_ORDER(tb->tb_path, h))==B_NR_ITEMS(Fh)) ? 0 : (n + 1);
-      n = B_N_CHILD(tb->FR[h],order_R)->dc_size / (DC_SIZE + KEY_SIZE);
+      n = dc_size(B_N_CHILD(tb->FR[h],order_R)) / (DC_SIZE + KEY_SIZE);
       set_parameters (tb, h, 0, -n-1, 0, NULL, -1, -1);
       return CARRY_ON;   
     }
@@ -2357,7 +2357,7 @@
     {  /* S[0] is the root now. */
 
 #ifdef CONFIG_REISERFS_CHECK
-      if ( -levbytes >= maxsize - B_BLK_HEAD(S0)->blk_free_space )
+      if ( -levbytes >= maxsize - blkh_free_space(B_BLK_HEAD(S0)) )
 	reiserfs_panic (tb->tb_sb, "vs-8240: dc_check_balance_leaf: attempt to create empty buffer tree");
 #endif
 
@@ -2572,7 +2572,7 @@
 	    reiserfs_panic (p_s_tb->tb_sb, "PAP-8270: get_neighbors: invalid position in the parent");
 #endif
 	
-	n_child_position = ( p_s_bh == p_s_tb->FL[n_h] ) ? p_s_tb->lkey[n_h] : B_BLK_HEAD(p_s_tb->FL[n_h])->blk_nr_item;
+	n_child_position = ( p_s_bh == p_s_tb->FL[n_h] ) ? p_s_tb->lkey[n_h] : blkh_nr_item(B_BLK_HEAD(p_s_tb->FL[n_h]));
 	n_son_number = B_N_CHILD_NUM(p_s_tb->FL[n_h], n_child_position);
 	n_repeat = CARRY_ON;
 	p_s_bh = reiserfs_bread(p_s_sb->s_dev, n_son_number, p_s_sb->s_blocksize, &n_repeat);
@@ -2590,7 +2590,8 @@
 	if ( ! B_IS_IN_TREE(p_s_bh) )
 	    reiserfs_panic (p_s_tb->tb_sb, "PAP-8280: get_neighbors: invalid child");
 	
-	if (! n_h && node_free_space (p_s_bh) != MAX_CHILD_SIZE (p_s_bh) - B_N_CHILD (p_s_tb->FL[0],n_child_position)->dc_size) {
+	if (! n_h && node_free_space (p_s_bh) != MAX_CHILD_SIZE (p_s_bh) -
+                    dc_size(B_N_CHILD (p_s_tb->FL[0],n_child_position))) {
 	    reiserfs_panic (p_s_tb->tb_sb, "PAP-8290: get_neighbors: invalid child size of left neighbor");
 	}
 #endif
@@ -2621,9 +2622,11 @@
 	p_s_tb->R[n_h] = p_s_bh;
 
 #ifdef CONFIG_REISERFS_CHECK
-	if (! n_h && node_free_space (p_s_bh) != MAX_CHILD_SIZE (p_s_bh) - B_N_CHILD (p_s_tb->FR[0],n_child_position)->dc_size) {
+	if (! n_h && node_free_space (p_s_bh) != MAX_CHILD_SIZE (p_s_bh) -
+        dc_size(B_N_CHILD (p_s_tb->FR[0],n_child_position))) {
 	    reiserfs_panic (p_s_tb->tb_sb, "PAP-8300: get_neighbors: invalid child size of right neighbor (%d != %d - %d)",
-			    node_free_space (p_s_bh), MAX_CHILD_SIZE (p_s_bh), B_N_CHILD (p_s_tb->FR[0],n_child_position)->dc_size);
+                        node_free_space (p_s_bh), MAX_CHILD_SIZE (p_s_bh),
+                        dc_size(B_N_CHILD (p_s_tb->FR[0],n_child_position)));
 	}
 #endif
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/ibalance.c reiserfsprogs-devel/reiserfscore/ibalance.c
--- reiserfsprogs-3.x.0j/reiserfscore/ibalance.c	Thu Mar 15 19:21:14 2001
+++ reiserfsprogs-devel/reiserfscore/ibalance.c	Mon Mar 26 18:35:21 2001
@@ -145,9 +145,9 @@
     
     /* make disk child array for insertion */
     for (i = 0; i < count; i ++) {
-	new_dc[i].dc_size = cpu_to_le16 (MAX_CHILD_SIZE(bh[i]) - 
+        set_dc_size(&(new_dc[i]), MAX_CHILD_SIZE(bh[i]) - 
 					 node_free_space (bh[i]));
-	new_dc[i].dc_block_number = cpu_to_le32 (bh[i]->b_blocknr);
+        set_dc_block_number( &(new_dc[i]), bh[i]->b_blocknr );
     }
     memcpy (dc, new_dc, DC_SIZE * count);
     
@@ -169,7 +169,9 @@
     mark_buffer_dirty (cur);
     
     if (cur_bi->bi_parent) {
-	B_N_CHILD (cur_bi->bi_parent,cur_bi->bi_position)->dc_size += count * (DC_SIZE + KEY_SIZE);
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD (cur_bi->bi_parent,cur_bi->bi_position);
+        set_dc_size( t_dc, dc_size(t_dc) + (count * (DC_SIZE + KEY_SIZE)) );
 	mark_buffer_dirty (cur_bi->bi_parent);
     }
     
@@ -208,7 +210,8 @@
     if ( del_num == 0 )
 	return;
 
-    nr = (blkh = B_BLK_HEAD(cur))->blk_nr_item;
+    blkh = B_BLK_HEAD(cur);
+    nr = blkh_nr_item(blkh);
 
     if ( first_p == 0 && del_num == nr + 1 ) {
 #ifdef CONFIG_REISERFS_CHECK
@@ -238,13 +241,15 @@
 
 
   /* sizes, item number */
-    blkh->blk_nr_item -= del_num;
-    blkh->blk_free_space += del_num * (KEY_SIZE +  DC_SIZE);
+    set_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);
+    set_blkh_free_space(blkh, blkh_free_space(blkh) + (del_num * (KEY_SIZE + DC_SIZE)));
 
     mark_buffer_dirty (cur);
  
     if (cur_bi->bi_parent) {
-	B_N_CHILD (cur_bi->bi_parent, cur_bi->bi_position)->dc_size -= del_num * (KEY_SIZE +  DC_SIZE);
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD (cur_bi->bi_parent, cur_bi->bi_position);
+        set_dc_size( t_dc, dc_size(t_dc) - (del_num * (KEY_SIZE + DC_SIZE) ) );
 	mark_buffer_dirty (cur_bi->bi_parent);
     }
 }
@@ -310,7 +315,8 @@
 	return;
 
 	/* coping */
-    nr_dest = (blkh = B_BLK_HEAD(dest))->blk_nr_item;
+    blkh = B_BLK_HEAD(dest);
+    nr_dest = blkh_nr_item(blkh);
 
     /*dest_order = (last_first == LAST_TO_FIRST) ? 0 : nr_dest;*/
     /*src_order = (last_first == LAST_TO_FIRST) ? (nr_src - cpy_num + 1) : 0;*/
@@ -336,13 +342,16 @@
     memcpy (key, B_N_PDELIM_KEY (src, src_order), KEY_SIZE * (cpy_num - 1));
 
     /* sizes, item number */
-    blkh->blk_nr_item += cpy_num - 1;
-    blkh->blk_free_space -= KEY_SIZE * (cpy_num - 1) + DC_SIZE * cpy_num;
+    set_blkh_nr_item(blkh, blkh_nr_item(blkh) + (cpy_num - 1) );
+    set_blkh_free_space(blkh, blkh_free_space(blkh)
+                            - (KEY_SIZE * (cpy_num - 1) + DC_SIZE * cpy_num));
 
     mark_buffer_dirty (dest);
     if (dest_bi->bi_parent) {
-	B_N_CHILD(dest_bi->bi_parent,dest_bi->bi_position)->dc_size +=
-	    KEY_SIZE * (cpy_num - 1) + DC_SIZE * cpy_num;
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD(dest_bi->bi_parent,dest_bi->bi_position);
+        set_dc_size( t_dc, dc_size(t_dc) +
+                        (KEY_SIZE * (cpy_num - 1) + DC_SIZE * cpy_num ) );
 	mark_buffer_dirty (dest_bi->bi_parent);
     }
 
@@ -405,12 +414,14 @@
 			"invalid position in dest (%d (key number %d)) or in src (%d (key number %d))",
 			dest_position_before, B_NR_ITEMS (dest), src_position, B_NR_ITEMS(src));
 
-    if (B_BLK_HEAD(dest)->blk_free_space < KEY_SIZE)
+    if (blk_free_space(B_BLK_HEAD(dest)) < KEY_SIZE)
 	reiserfs_panic (0, "internal_insert_key", 
-			"no enough free space (%d) in dest buffer", B_BLK_HEAD(dest)->blk_free_space);
+			"no enough free space (%d) in dest buffer",
+                        blk_free_space(B_BLK_HEAD(dest)));
 #endif
 
-    nr = (blkh=B_BLK_HEAD(dest))->blk_nr_item;
+    blkh = B_BLK_HEAD(dest);
+    nr = blkh_nr_item(blkh);
 
     /* prepare space for inserting key */
     key = B_N_PDELIM_KEY (dest, dest_position_before);
@@ -420,13 +431,15 @@
     memcpy (key, B_N_PDELIM_KEY(src, src_position), KEY_SIZE);
 
     /* Change dirt, free space, item number fields. */
-    blkh->blk_nr_item ++;
-    blkh->blk_free_space -= KEY_SIZE;
+    set_blkh_nr_item( blkh, blkh_nr_item(blkh) + 1 );
+    set_blkh_free_space( blkh, blkh_free_space(blkh) - KEY_SIZE );
 
     mark_buffer_dirty (dest);
 
     if (dest_bi->bi_parent) {
-	B_N_CHILD(dest_bi->bi_parent,dest_bi->bi_position)->dc_size += KEY_SIZE;
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD(dest_bi->bi_parent,dest_bi->bi_position);
+        set_dc_size( t_dc, dc_size(t_dc) + KEY_SIZE );
 	mark_buffer_dirty (dest_bi->bi_parent);
     }
 }
@@ -584,7 +597,8 @@
 	    struct buffer_head *new_root;
 
 #ifdef CONFIG_REISERFS_CHECK
-	    if (n || B_BLK_HEAD (tbSh)->blk_free_space != MAX_CHILD_SIZE(tbSh) - DC_SIZE)
+	    if (n || blkh_free_space(B_BLK_HEAD(tbSh)) !=
+                MAX_CHILD_SIZE(tbSh) - DC_SIZE)
 		reiserfs_panic (tb->tb_sb, "balance_internal_when_delete", "buffer must have only 0 keys (%d)",
 				n);
 
@@ -780,7 +794,7 @@
     if ( tb->lnum[h] > 0 ) {
 	/* shift lnum[h] items from S[h] to the left neighbor L[h].
 	   check how many of new items fall into L[h] or CFL[h] after shifting */
-	n = B_BLK_HEAD(tb->L[h])->blk_nr_item; /* number of items in L[h] */
+	n = blkh_nr_item(B_BLK_HEAD(tb->L[h])); /* number of items in L[h] */
 	if ( tb->lnum[h] <= child_pos ) {
 	    /* new items don't fall into L[h] or CFL[h] */
 	    internal_shift_left (INTERNAL_SHIFT_FROM_S_TO_L, tb, h, tb->lnum[h]);
@@ -814,10 +828,10 @@
 	    replace_lkey(tb, h, insert_key + k);
 
 	    /* replace the first node-ptr in S[h] by node-ptr to insert_ptr[k] */
-	    (dc = B_N_CHILD(tbSh, 0))->dc_size =
-		MAX_CHILD_SIZE(insert_ptr[k]) -
-		B_BLK_HEAD(insert_ptr[k])->blk_free_space;
-	    dc->dc_block_number = insert_ptr[k]->b_blocknr; 
+            dc = B_N_CHILD(tbSh, 0);
+            set_dc_size(dc, MAX_CHILD_SIZE(insert_ptr[k]) -
+                                blkh_free_space(B_BLK_HEAD(insert_ptr[k])));
+            set_dc_block_number(dc, insert_ptr[k]->b_blocknr);
 
 	    mark_buffer_dirty (tbSh);
 
@@ -832,7 +846,7 @@
     if ( tb->rnum[h] > 0 ) {
 	/*shift rnum[h] items from S[h] to the right neighbor R[h]*/
 	/* check how many of new items fall into R or CFR after shifting */
-	n = B_BLK_HEAD (tbSh)->blk_nr_item; /* number of items in S[h] */
+	n = blkh_nr_item(B_BLK_HEAD(tbSh)); /* number of items in S[h] */
 	if ( n - tb->rnum[h] >= child_pos )
 	    /* new items fall into S[h] */
 	    /*internal_shift_right(tb,h,tbSh,tb->CFR[h],tb->rkey[h],tb->R[h],tb->rnum[h]);*/
@@ -868,10 +882,11 @@
 		replace_rkey(tb, h, insert_key + insert_num - k - 1);
 
 		/* replace the first node-ptr in R[h] by node-ptr insert_ptr[insert_num-k-1]*/
-		(dc = B_N_CHILD(tb->R[h], 0))->dc_size =
-		    MAX_CHILD_SIZE(insert_ptr[insert_num-k-1]) -
-		    B_BLK_HEAD(insert_ptr[insert_num-k-1])->blk_free_space;
-		dc->dc_block_number = insert_ptr[insert_num-k-1]->b_blocknr;
+                dc = B_N_CHILD(tb->R[h], 0);
+                set_dc_size( dc, MAX_CHILD_SIZE(insert_ptr[insert_num-k-1]) -
+                    blkh_free_space(B_BLK_HEAD(insert_ptr[insert_num-k-1])));
+		set_dc_block_number( dc,
+                    insert_ptr[insert_num-k-1]->b_blocknr );
 
 		mark_buffer_dirty (tb->R[h]);
 		    
@@ -909,15 +924,18 @@
 	    reiserfs_panic(0, "balance_internal", "One new node required for creating the new root");
 	/* S[h] = empty buffer from the list FEB. */
 	tbSh = get_FEB (tb);
-	B_BLK_HEAD(tbSh)->blk_level = h + 1;
+        set_blkh_level( B_BLK_HEAD(tbSh), h + 1 );
 	
 	/* Put the unique node-pointer to S[h] that points to S[h-1]. */
 
-	(dc = B_N_CHILD(tbSh, 0))->dc_block_number = tbSh_1->b_blocknr;
-	dc->dc_size = MAX_CHILD_SIZE (tbSh_1) - B_BLK_HEAD(tbSh_1)->blk_free_space;
+        dc = B_N_CHILD(tbSh, 0);
+        set_dc_block_number(dc, tbSh_1->b_blocknr );
+        set_dc_size(dc, MAX_CHILD_SIZE (tbSh_1) -
+                                        blkh_free_space(B_BLK_HEAD(tbSh_1)));
 	
 	tb->insert_size[h] -= DC_SIZE;
-	B_BLK_HEAD(tbSh)->blk_free_space -= DC_SIZE;
+        set_blkh_free_space( B_BLK_HEAD(tbSh),
+                            blkh_free_space(B_BLK_HEAD(tbSh)) - DC_SIZE );
 
 	mark_buffer_dirty (tbSh);
 	
@@ -940,7 +958,7 @@
 	/* S_new = free buffer from list FEB */
 	S_new = get_FEB(tb);
 
-	B_BLK_HEAD(S_new)->blk_level = h + 1;
+        set_blkh_level( B_BLK_HEAD(S_new), h + 1 );
     
 
 	dest_bi.bi_bh = S_new;
@@ -950,7 +968,7 @@
 	src_bi.bi_parent = PATH_H_PPARENT (tb->tb_path, h);
 	src_bi.bi_position = PATH_H_POSITION (tb->tb_path, h + 1);
 		
-	n = B_BLK_HEAD(tbSh)->blk_nr_item; /* number of items in S[h] */
+	n = blkh_nr_item(B_BLK_HEAD(tbSh)); /* number of items in S[h] */
 	snum = (insert_num + n + 1)/2;
 	if ( n - snum >= child_pos ) {
 	    /* new items don't fall into S_new */
@@ -992,10 +1010,10 @@
 		   KEY_SIZE);
 	    /* replace first node-ptr in S_new by node-ptr to insert_ptr[insert_num-k-1] */
 
-	    (dc = B_N_CHILD(S_new,0))->dc_size =
-		MAX_CHILD_SIZE(insert_ptr[insert_num-k-1]) -
-		B_BLK_HEAD(insert_ptr[insert_num-k-1])->blk_free_space;
-	    dc->dc_block_number =	insert_ptr[insert_num-k-1]->b_blocknr; 
+            dc = B_N_CHILD(S_new,0);
+            set_dc_size(dc, MAX_CHILD_SIZE(insert_ptr[insert_num-k-1]) -
+                blkh_free_space(B_BLK_HEAD(insert_ptr[insert_num-k-1])));
+            set_dc_block_number(dc, insert_ptr[insert_num-k-1]->b_blocknr);
 
 	    mark_buffer_dirty (S_new);
 			
@@ -1019,7 +1037,7 @@
 	/*brelse(S_new);*/
     }
 
-    n = B_BLK_HEAD(tbSh)->blk_nr_item; /*number of items in S[h] */
+    n = blkh_nr_item(B_BLK_HEAD(tbSh)); /*number of items in S[h] */
 
 #ifndef FU //REISERFS_FSCK
     if ( -1 <= child_pos && child_pos <= n && insert_num > 0 ) {
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/lbalance.c reiserfsprogs-devel/reiserfscore/lbalance.c
--- reiserfsprogs-3.x.0j/reiserfscore/lbalance.c	Tue Mar 20 13:09:40 2001
+++ reiserfsprogs-devel/reiserfscore/lbalance.c	Mon Mar 26 18:35:21 2001
@@ -50,9 +50,9 @@
     /* length of all record to be copied and first byte of the last of them */
     deh = B_I_DEH (source, ih);
     if (copy_count) {
-	copy_records_len = (from ? deh[from - 1].deh_location : ih->ih_item_len) - 
-	    deh[from + copy_count - 1].deh_location;
-	records = source->b_data + ih->ih_item_location + deh[from + copy_count - 1].deh_location;
+	copy_records_len = (from ? deh_location(&(deh[from - 1])) : ih_item_len(ih)) - 
+	    deh_location(&(deh[from + copy_count - 1]));
+	records = source->b_data + ih_location(ih) + deh_location(&(deh[from + copy_count - 1]));
     } else {
 	copy_records_len = 0;
 	records = 0;
@@ -77,24 +77,24 @@
 	memcpy (&new_ih.ih_key, &ih->ih_key, KEY_SIZE);
 
 	/* calculate item len */
-	new_ih.ih_item_len = cpu_to_le16 (DEH_SIZE * copy_count + copy_records_len);
+        set_ih_item_len( &new_ih, (DEH_SIZE * copy_count + copy_records_len ));
 	set_entry_count (&new_ih, 0);
     
 	if (last_first == LAST_TO_FIRST) {
 	    /* form key by the following way */
 	    if (from < ih_entry_count (ih)) {
-		new_ih.ih_key.u.k_offset_v1.k_offset = deh[from].deh_offset;
-		new_ih.ih_key.u.k_offset_v1.k_uniqueness = DIRENTRY_UNIQUENESS;
+		new_ih.ih_key.u.k_offset_v1.k_offset = deh[from].deh_offset; /* ok, both 32-bit LE */
+		new_ih.ih_key.u.k_offset_v1.k_uniqueness = cpu_to_le32(DIRENTRY_UNIQUENESS);
 		/*memcpy (&new_ih.ih_key.k_offset, &deh[from].deh_offset, SHORT_KEY_SIZE);*/
 	    } else {
 		/* no entries will be copied to this item in this function */
-		new_ih.ih_key.u.k_offset_v1.k_offset = MAX_KEY1_OFFSET;
+		new_ih.ih_key.u.k_offset_v1.k_offset = cpu_to_le32(MAX_KEY1_OFFSET);
 		/* this item is not yet valid, but we want I_IS_DIRECTORY_ITEM to return 1 for it, so we -1 */
-		new_ih.ih_key.u.k_offset_v1.k_uniqueness = DIRENTRY_UNIQUENESS/*TYPE_DIRECTORY_MAX*/;
+		new_ih.ih_key.u.k_offset_v1.k_uniqueness = cpu_to_le32(DIRENTRY_UNIQUENESS)/*TYPE_DIRECTORY_MAX*/;
 	    }
 	}
-	set_key_format (&new_ih, ih_key_format (ih));
-	new_ih.ih_format.fsck_need = ih->ih_format.fsck_need;
+        /* Copy both key_format and fsck_need */
+        new_ih.ih_formats.em_ih_format = ih->ih_formats.em_ih_format;
     
 	/* insert item into dest buffer */
 	leaf_insert_into_buf (fs, dest_bi, (last_first == LAST_TO_FIRST) ? 0 : B_NR_ITEMS(dest), &new_ih, NULL, 0);
@@ -144,7 +144,7 @@
 		return 0;
       
 #ifdef CONFIG_REISERFS_CHECK
-	if ( ! ih->ih_item_len )
+	if ( ! ih_item_len(ih) )
 	    reiserfs_panic (0, "vs-10010: leaf_copy_boundary_item: item can not have empty dynamic length");
 #endif
       
@@ -160,11 +160,11 @@
 	   part defined by 'bytes_or_entries'; if bytes_or_entries == -1 copy whole body; don't create new item header
 	*/
 	if ( bytes_or_entries == -1 )
-	    bytes_or_entries = ih->ih_item_len;
+	    bytes_or_entries = ih_item_len(ih);
 
 #ifdef CONFIG_REISERFS_CHECK
 	else {
-	    if (bytes_or_entries == ih->ih_item_len && I_IS_INDIRECT_ITEM(ih))
+	    if (bytes_or_entries == ih_item_len(ih) && I_IS_INDIRECT_ITEM(ih))
 		if (ih_free_space (ih))
 		    reiserfs_panic (0, "vs-10020: leaf_copy_boundary_item: "
 				    "last unformatted node must be filled entirely (free_space=%d)",
@@ -175,7 +175,7 @@
 	/* merge first item (or its part) of src buffer with the last
 	   item of dest buffer. Both are of the same file */
 	leaf_paste_in_buffer (fs, dest_bi,
-			      dest_nr_item - 1, dih->ih_item_len, bytes_or_entries, B_I_PITEM(src,ih), 0
+			      dest_nr_item - 1, ih_item_len(dih), bytes_or_entries, B_I_PITEM(src,ih), 0
 	    );
       
 	if (I_IS_INDIRECT_ITEM(dih)) {
@@ -185,7 +185,7 @@
 				"merge to left: last unformatted node of non-last indirect item must be filled entirely (free_space=%d)",
 				ih_free_space (dih));
 #endif
-	    if (bytes_or_entries == ih->ih_item_len)
+	    if (bytes_or_entries == ih_item_len(ih))
 		//dih->u.ih_free_space = ih->u.ih_free_space;
 		set_free_space (dih, ih_free_space (ih));
 	}
@@ -234,7 +234,7 @@
 
     if ( bytes_or_entries == -1 ) {
 	/* bytes_or_entries = length of last item body of SOURCE */
-	bytes_or_entries = ih->ih_item_len;
+	bytes_or_entries = ih_item_len(ih);
 
 #ifdef CONFIG_REISERFS_CHECK
 	if (get_offset (&dih->ih_key) != get_offset (&ih->ih_key) + get_bytes_number (ih, src->b_size))/*I_DNM_DATA_LEN(ih))*/
@@ -253,9 +253,9 @@
     } else {
 	/* merge to right only part of item */
 #ifdef CONFIG_REISERFS_CHECK
-	if ( ih->ih_item_len <= bytes_or_entries )
+	if ( ih_item_len(ih) <= bytes_or_entries )
 	    reiserfs_panic (0, "vs-10060: leaf_copy_boundary_item: no so much bytes %lu (needed %lu)",
-			    ih->ih_item_len, bytes_or_entries);
+			    ih_item_len(ih), bytes_or_entries);
 #endif
     
 	/* change first item key of the DEST */
@@ -279,7 +279,7 @@
 	}
     }
   
-    leaf_paste_in_buffer (fs, dest_bi, 0, 0, bytes_or_entries, B_I_PITEM(src,ih) + ih->ih_item_len - bytes_or_entries, 0);
+    leaf_paste_in_buffer (fs, dest_bi, 0, 0, bytes_or_entries, B_I_PITEM(src,ih) + ih_item_len(ih) - bytes_or_entries, 0);
     return 1;
 }
 
@@ -326,7 +326,8 @@
     if (cpy_num == 0)
 	return;
 
-    nr = (blkh = B_BLK_HEAD(dest))->blk_nr_item;
+    blkh = B_BLK_HEAD(dest);
+    nr = blkh_nr_item(blkh);
   
     /* we will insert items before 0-th or nr-th item in dest buffer. It depends of last_first parameter */
     dest_before = (last_first == LAST_TO_FIRST) ? 0 : nr;
@@ -335,9 +336,9 @@
     ih = B_N_PITEM_HEAD (dest, dest_before);
 
 #ifdef CONFIG_REISERFS_CHECK
-    if (blkh->blk_free_space < cpy_num * IH_SIZE) {
+    if (blkh_free_space(blkh) < cpy_num * IH_SIZE) {
 	reiserfs_panic (0, "vs-10140: leaf_copy_items_entirely: not enough free space for headers %d (needed %d)",
-			blkh->blk_free_space, cpy_num * IH_SIZE);
+			blkh_free_space(blkh), cpy_num * IH_SIZE);
     }
 #endif
 
@@ -347,23 +348,23 @@
     /* copy item headers */
     memcpy (ih, B_N_PITEM_HEAD (src, first), cpy_num * IH_SIZE);
 
-    blkh->blk_free_space -= IH_SIZE * cpy_num;
+    set_blkh_free_space(blkh, blkh_free_space(blkh) - (IH_SIZE * cpy_num) );
 
     /* location of unmovable item */
-    j = location = (dest_before == 0) ? dest->b_size : (ih-1)->ih_item_location;
+    j = location = (dest_before == 0) ? dest->b_size : ih_location(ih-1);
     for (i = dest_before; i < nr + cpy_num; i ++)
-	ih[i-dest_before].ih_item_location =
-	    (location -= ih[i-dest_before].ih_item_len);
+        set_ih_location( &(ih[i-dest_before]),
+	    (location -= ih_item_len( &(ih[i-dest_before]))));
 
     /* prepare space for items */
-    last_loc = ih[nr+cpy_num-1-dest_before].ih_item_location;
-    last_inserted_loc = ih[cpy_num-1].ih_item_location;
+    last_loc = ih_location( &(ih[nr+cpy_num-1-dest_before]) );
+    last_inserted_loc = ih_location( &(ih[cpy_num-1]) );
 
     /* check free space */
 #ifdef CONFIG_REISERFS_CHECK
-    if (blkh->blk_free_space < j - last_inserted_loc) {
+    if (blkh_free_space(blkh) < j - last_inserted_loc) {
 	reiserfs_panic (0, "vs-10150: leaf_copy_items_entirely: not enough free space for items %d (needed %d)",
-			blkh->blk_free_space, j - last_inserted_loc);
+			blkh_free_space(blkh), j - last_inserted_loc);
     }
 #endif
 
@@ -376,21 +377,23 @@
 	    j - last_inserted_loc);
 
     /* sizes, item number */
-    blkh->blk_nr_item += cpy_num;  
-    blkh->blk_free_space -= j - last_inserted_loc;
+    set_blkh_nr_item(blkh, blkh_nr_item(blkh) + cpy_num);
+    set_blkh_free_space(blkh, blkh_free_space(blkh) - (j - last_inserted_loc));
   
     mark_buffer_dirty (dest);
 
     if (dest_bi->bi_parent) {
+        struct disk_child *t_dc;
 #ifdef CONFIG_REISERFS_CHECK
-	if (B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)->dc_block_number != dest->b_blocknr) {
+	if (dc_block_number(B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)) != dest->b_blocknr) {
 	    reiserfs_panic (0, "vs-10160: leaf_copy_items_entirely: "
 			    "block number in bh does not match to field in disk_child structure %lu and %lu",
-			    dest->b_blocknr, B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)->dc_block_number);
+			    dest->b_blocknr, dc_block_number(B_N_CHILD(dest_bi->bi_parent, dest_bi->bi_position)));
 	}
 #endif
-	B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position)->dc_size +=
-	    j - last_inserted_loc + IH_SIZE * cpy_num;
+        t_dc = B_N_CHILD (dest_bi->bi_parent, dest_bi->bi_position);
+        set_dc_size(t_dc, dc_size(t_dc) +
+                                (j - last_inserted_loc + IH_SIZE * cpy_num));
     
 	mark_buffer_dirty(dest_bi->bi_parent);
     }
@@ -423,10 +426,10 @@
 	       n_ih = new item_header;
 	    */
 	    memcpy (&n_ih, ih, IH_SIZE);
-	    n_ih.ih_item_len = cpy_bytes;
+            set_ih_item_len(&n_ih, cpy_bytes);
 	    if (I_IS_INDIRECT_ITEM(ih)) {
 #ifdef CONFIG_REISERFS_CHECK
-		if (cpy_bytes == ih->ih_item_len && ih_free_space (ih))
+		if (cpy_bytes == ih_item_len(ih) && ih_free_space (ih))
 		    reiserfs_panic (0, "vs-10180: leaf_item_bottle: " 
 				    "when whole indirect item is bottle to left neighbor, it must have free_space==0 (not %lu)",
 				    ih_free_space (ih));
@@ -440,8 +443,8 @@
 		reiserfs_panic (0, "vs-10190: leaf_item_bottle: item %h should not be mergeable", ih);
 #endif
 	    //n_ih.ih_version = ih->ih_version;
-	    set_key_format (&n_ih, ih_key_format (ih));
-	    n_ih.ih_format.fsck_need = ih->ih_format.fsck_need;
+            /* Copy both key_format and fsck need at the same time */
+            n_ih.ih_formats.em_ih_format = ih->ih_formats.em_ih_format;
 	    leaf_insert_into_buf (fs, dest_bi, B_NR_ITEMS(dest), &n_ih, B_N_PITEM (src, item_num), 0);
 	}
     } else {
@@ -459,7 +462,7 @@
       
 	    if (I_IS_DIRECT_ITEM(ih)) {
 		//n_ih.ih_key.k_offset = ih->ih_key.k_offset + ih->ih_item_len - cpy_bytes;
-		set_offset (key_format (&ih->ih_key), &n_ih.ih_key, get_offset (&ih->ih_key) + ih->ih_item_len - cpy_bytes);
+		set_offset (key_format (&ih->ih_key), &n_ih.ih_key, get_offset (&ih->ih_key) + ih_item_len(ih) - cpy_bytes);
 		//n_ih.ih_key.k_uniqueness = TYPE_DIRECT;
 		set_type (key_format (&ih->ih_key), &n_ih.ih_key, TYPE_DIRECT);
 		//n_ih.u.ih_free_space = USHRT_MAX;
@@ -480,11 +483,10 @@
 	    }
       
 	    /* set item length */
-	    n_ih.ih_item_len = cpu_to_le16 (cpy_bytes);
-	    //n_ih.ih_version = ih->ih_version;
-	    set_key_format (&n_ih, ih_key_format (ih));
-	    n_ih.ih_format.fsck_need = ih->ih_format.fsck_need;
-	    leaf_insert_into_buf (fs, dest_bi, 0, &n_ih, B_N_PITEM(src,item_num) + ih->ih_item_len - cpy_bytes, 0);
+            set_ih_item_len( &n_ih, cpy_bytes );
+	    /* Copy both key_format and fsck need */
+            n_ih.ih_formats.em_ih_format = ih->ih_formats.em_ih_format;
+	    leaf_insert_into_buf (fs, dest_bi, 0, &n_ih, B_N_PITEM(src,item_num) + ih_item_len(ih) - cpy_bytes, 0);
 	}
     }
 }
@@ -810,7 +812,7 @@
 	        len = ih_entry_count(ih);
 	    else
 		/* len = body len of item */
- 	        len = ih->ih_item_len;
+ 	        len = ih_item_len(ih);
 	    
 	    /* delete the part of the last item of the bh 
 	       do not delete item header
@@ -838,15 +840,17 @@
     int last_loc, unmoved_loc;
     char * to;
 
-    nr = (blkh = B_BLK_HEAD (bh))->blk_nr_item;
+    blkh = B_BLK_HEAD (bh);
+    nr = blkh_nr_item(blkh);
 
 #ifdef CONFIG_REISERFS_CHECK
     /* check free space */
-    if (blkh->blk_free_space < inserted_item_ih->ih_item_len + IH_SIZE)
+    if (blkh_free_space(blkh) < ih_item_len(inserted_item_ih) + IH_SIZE)
 	reiserfs_panic (0, "leaf_insert_into_buf: 10170: not enough free space: needed %d, available %d",
-			inserted_item_ih->ih_item_len + IH_SIZE, blkh->blk_free_space);
-    if (zeros_number > inserted_item_ih->ih_item_len)
-	reiserfs_panic (0, "vs-10172: leaf_insert_into_buf: zero number == %d, item length == %d", zeros_number, inserted_item_ih->ih_item_len);
+			ih_item_len(inserted_item_ih) + IH_SIZE,
+                        blkh_free_space(blkh));
+    if (zeros_number > ih_item_len(inserted_item_ih))
+	reiserfs_panic (0, "vs-10172: leaf_insert_into_buf: zero number == %d, item length == %d", zeros_number, ih_item_len(inserted_item_ih));
 #endif /* CONFIG_REISERFS_CHECK */
 
 
@@ -854,13 +858,13 @@
     ih = B_N_PITEM_HEAD (bh, before);
 
     /* prepare space for the body of new item */
-    last_loc = nr ? ih[nr - before - 1].ih_item_location : bh->b_size;
-    unmoved_loc = before ? (ih-1)->ih_item_location : bh->b_size;
+    last_loc = nr ? ih_location( &(ih[nr - before - 1]) ) : bh->b_size;
+    unmoved_loc = before ? ih_location(ih-1) : bh->b_size;
 
-    memmove (bh->b_data + last_loc - inserted_item_ih->ih_item_len, 
+    memmove (bh->b_data + last_loc - ih_item_len(inserted_item_ih), 
 	     bh->b_data + last_loc, unmoved_loc - last_loc);
 
-    to = bh->b_data + unmoved_loc - inserted_item_ih->ih_item_len;
+    to = bh->b_data + unmoved_loc - ih_item_len(inserted_item_ih);
     memset (to, 0, zeros_number);
     to += zeros_number;
 
@@ -869,10 +873,10 @@
 	//if (mem_mode == REISERFS_USER_MEM)
 	//  copy_from_user (to, inserted_item_body, inserted_item_ih->ih_item_len - zeros_number);
 	//else {
-	memmove (to, inserted_item_body, inserted_item_ih->ih_item_len - zeros_number);
+	memmove (to, inserted_item_body, ih_item_len(inserted_item_ih) - zeros_number);
     //}
     else
-	memset(to, '\0', inserted_item_ih->ih_item_len - zeros_number);
+	memset(to, '\0', ih_item_len(inserted_item_ih) - zeros_number);
   
     /* insert item header */
     memmove (ih + 1, ih, IH_SIZE * (nr - before));
@@ -880,17 +884,19 @@
   
     /* change locations */
     for (i = before; i < nr + 1; i ++)
-	ih[i-before].ih_item_location =
-	    (unmoved_loc -= ih[i-before].ih_item_len);
+        set_ih_location( &(ih[i-before]), (unmoved_loc -= ih_item_len(&(ih[i-before]))));
   
     /* sizes, free space, item number */
-    blkh->blk_nr_item ++;
-    blkh->blk_free_space -= (IH_SIZE + inserted_item_ih->ih_item_len);
+    set_blkh_nr_item(blkh, blkh_nr_item(blkh) + 1 );
+    set_blkh_free_space(blkh, blkh_free_space(blkh) -
+                                (IH_SIZE + ih_item_len(inserted_item_ih)));
 
     mark_buffer_dirty(bh) ;
 
     if (bi->bi_parent) { 
-	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size += (IH_SIZE + inserted_item_ih->ih_item_len);
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD (bi->bi_parent, bi->bi_position);
+        set_dc_size(t_dc, dc_size(t_dc) + (IH_SIZE + ih_item_len(inserted_item_ih)));
 	mark_buffer_dirty(bi->bi_parent) ;
     }
 
@@ -918,14 +924,15 @@
     int last_loc, unmoved_loc;
 
 
-    nr = (blkh = B_BLK_HEAD(bh))->blk_nr_item;
+    blkh = B_BLK_HEAD(bh);
+    nr = blkh_nr_item(blkh);
 
 #ifdef CONFIG_REISERFS_CHECK
     /* check free space */
-    if (blkh->blk_free_space < paste_size)
+    if (blkh_free_space(blkh) < paste_size)
 	reiserfs_panic (th->t_super, "vs-10175: leaf_paste_in_buffer: "
 			"not enough free space: needed %d, available %d",
-			paste_size, blkh->blk_free_space);
+			paste_size, blkh_free_space(blkh));
     if (zeros_number > paste_size) {
 	print_tb (init_mode, init_item_pos, init_pos_in_item, &init_tb, "10177");
 	reiserfs_panic (th->t_super, "vs-10177: leaf_paste_in_buffer: "
@@ -937,8 +944,8 @@
     /* item to be appended */
     ih = B_N_PITEM_HEAD(bh, affected_item_num);
 
-    last_loc = ih[nr - affected_item_num - 1].ih_item_location;
-    unmoved_loc = affected_item_num ? (ih-1)->ih_item_location : bh->b_size;  
+    last_loc = ih_location( &(ih[nr - affected_item_num - 1]));
+    unmoved_loc = affected_item_num ? ih_location(ih-1) : bh->b_size;  
 
     /* prepare space */
     memmove (bh->b_data + last_loc - paste_size, bh->b_data + last_loc,
@@ -947,7 +954,8 @@
 
     /* change locations */
     for (i = affected_item_num; i < nr; i ++)
-	ih[i-affected_item_num].ih_item_location -= paste_size;
+        set_ih_location( &(ih[i-affected_item_num]),
+            ih_location( &(ih[i-affected_item_num])) - paste_size );
 
     if ( body ) {
 	if (!I_IS_DIRECTORY_ITEM(ih)) {
@@ -958,11 +966,11 @@
 	    {
 		if (!pos_in_item) {
 		    /* shift data to right */
-		    memmove (bh->b_data + ih->ih_item_location + paste_size, 
-			     bh->b_data + ih->ih_item_location, ih->ih_item_len);
+		    memmove (bh->b_data + ih_location(ih) + paste_size, 
+			     bh->b_data + ih_location(ih), ih_item_len(ih));
 		    /* paste data in the head of item */
-		    memset (bh->b_data + ih->ih_item_location, 0, zeros_number);
-		    memcpy (bh->b_data + ih->ih_item_location + zeros_number, body, paste_size - zeros_number);
+		    memset (bh->b_data + ih_location(ih), 0, zeros_number);
+		    memcpy (bh->b_data + ih_location(ih) + zeros_number, body, paste_size - zeros_number);
 		} else {
 		    memset (bh->b_data + unmoved_loc - paste_size, 0, zeros_number);
 		    memcpy (bh->b_data + unmoved_loc - paste_size + zeros_number, body, paste_size - zeros_number);
@@ -973,15 +981,17 @@
     else
 	memset(bh->b_data + unmoved_loc - paste_size,'\0',paste_size);
 
-    ih->ih_item_len += paste_size;
+    set_ih_item_len(ih, ih_item_len(ih) + paste_size );
 
     /* change free space */
-    blkh->blk_free_space -= paste_size;
+    set_blkh_free_space(blkh, blkh_free_space(blkh) - paste_size );
 
     mark_buffer_dirty(bh) ;
 
     if (bi->bi_parent) { 
-	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size += paste_size;
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD (bi->bi_parent, bi->bi_position);
+        set_dc_size(t_dc, dc_size(t_dc) + paste_size );
 	mark_buffer_dirty(bi->bi_parent);
     }
     if (who_is_this (bh->b_data, bh->b_size) != THE_LEAF)
@@ -1029,17 +1039,17 @@
 
     /* first byte of remaining entries, those are BEFORE cut entries
        (prev_record) and length of all removed records (cut_records_len) */
-    prev_record_offset = (from ? deh[from - 1].deh_location : ih->ih_item_len);
-    cut_records_len = prev_record_offset/*from_record*/ - deh[from + del_count - 1].deh_location;
+    prev_record_offset = (from ? deh_location(&(deh[from - 1])) : ih_item_len(ih));
+    cut_records_len = prev_record_offset/*from_record*/ - deh_location(&(deh[from + del_count - 1]));
     prev_record = item + prev_record_offset;
 
 
     /* adjust locations of remaining entries */
     for (i = ih_entry_count (ih) - 1; i > from + del_count - 1; i --)
-	deh[i].deh_location -= (DEH_SIZE * del_count);
+        set_deh_location(&(deh[i]), deh_location(&(deh[i])) - (DEH_SIZE * del_count ) );
 
     for (i = 0; i < from; i ++)
-	deh[i].deh_location -= DEH_SIZE * del_count + cut_records_len;
+        set_deh_location(&(deh[i]), deh_location(&(deh[i])) - (DEH_SIZE * del_count + cut_records_len ) );
 
     set_entry_count (ih, ih_entry_count (ih) - del_count);
 
@@ -1050,7 +1060,7 @@
   
     /* shift records, those are BEFORE removed entries */
     memmove (prev_record - cut_records_len - DEH_SIZE * del_count,
-	     prev_record, item + ih->ih_item_len - prev_record);
+	     prev_record, item + ih_item_len(ih) - prev_record);
 
     return DEH_SIZE * del_count + cut_records_len;
 }
@@ -1075,7 +1085,8 @@
     int last_loc, unmoved_loc;
     int i;
 
-    nr = (blkh = B_BLK_HEAD (bh))->blk_nr_item;
+    blkh = B_BLK_HEAD(bh);
+    nr = blkh_nr_item(blkh);
 
     /* item head of truncated item */
     ih = B_N_PITEM_HEAD (bh, cut_item_num);
@@ -1091,7 +1102,7 @@
                     "when 0-th enrty of item is cut, that item must be first in the node, not %d-th", cut_item_num);
 #endif
             /* change item key by key of first entry in the item */
-	    ih->ih_key.u.k_offset_v1.k_offset = B_I_DEH (bh, ih)->deh_offset;
+	    ih->ih_key.u.k_offset_v1.k_offset = B_I_DEH (bh, ih)->deh_offset; /* both 32-bit LE */
 	    
             /*memcpy (&ih->ih_key.k_offset, &(B_I_DEH (bh, ih)->deh_offset), SHORT_KEY_SIZE);*/
 	    }
@@ -1101,15 +1112,15 @@
         if (I_IS_STAT_DATA_ITEM (ih))
 	    reiserfs_panic (th->t_super, "leaf_cut_from_buffer: 10195: item is stat data");
 	
-        if (pos_in_item && pos_in_item + cut_size != ih->ih_item_len )
+        if (pos_in_item && pos_in_item + cut_size != ih_item_len(ih) )
             reiserfs_panic (th->t_super, "cut_from_buf: 10200: invalid offset (%lu) or trunc_size (%lu) or ih_item_len (%lu)",
-			    pos_in_item, cut_size, ih->ih_item_len);
+			    pos_in_item, cut_size, ih_item_len(ih));
 #endif
 
         /* shift item body to left if cut is from the head of item */
         if (pos_in_item == 0) {
-            memmove (bh->b_data + ih->ih_item_location, bh->b_data + ih->ih_item_location + cut_size,
-                ih->ih_item_len - cut_size);
+            memmove (bh->b_data + ih_location(ih), bh->b_data + ih_location(ih) + cut_size,
+                ih_item_len(ih) - cut_size);
 
             /* change key of item */
             if (I_IS_DIRECT_ITEM(ih)) {
@@ -1120,7 +1131,7 @@
                 set_offset (key_format (&ih->ih_key), &ih->ih_key, 
 			    get_offset (&ih->ih_key) + (cut_size / UNFM_P_SIZE) * bh->b_size);
 #ifdef CONFIG_REISERFS_CHECK
-                if ( ih->ih_item_len == cut_size && ih_free_space (ih) )
+                if ( ih_item_len(ih) == cut_size && ih_free_space (ih) )
                     reiserfs_panic (th->t_super, "leaf_cut_from_buf: 10205: invalid ih_free_space (%lu)", ih_free_space (ih));
 #endif
 	        }
@@ -1129,10 +1140,10 @@
   
 
     /* location of the last item */
-    last_loc = ih[nr - cut_item_num - 1].ih_item_location;
+    last_loc = ih_location( &(ih[nr - cut_item_num - 1]) );
 
     /* location of the item, which is remaining at the same place */
-    unmoved_loc = cut_item_num ? (ih-1)->ih_item_location : bh->b_size;
+    unmoved_loc = cut_item_num ? ih_location(ih-1) : bh->b_size;
 
 
     /* shift */
@@ -1140,7 +1151,7 @@
 	       unmoved_loc - last_loc - cut_size);
 
     /* change item length */
-    ih->ih_item_len -= cut_size;
+    set_ih_item_len(ih, ih_item_len(ih) - cut_size);
   
     if (I_IS_INDIRECT_ITEM(ih)) {
         if (pos_in_item)
@@ -1150,16 +1161,19 @@
 
     /* change locations */
     for (i = cut_item_num; i < nr; i ++)
-        ih[i-cut_item_num].ih_item_location += cut_size;
+        set_ih_location( &(ih[i-cut_item_num]),
+            ih_location( &(ih[i-cut_item_num])) + cut_size );
 
     /* size, free space */
-    blkh->blk_free_space += cut_size;
+    set_blkh_free_space(blkh, blkh_free_space(blkh) + cut_size);
 
     mark_buffer_dirty(bh);
     
     if (bi->bi_parent) { 
-      B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size -= cut_size; 
-      mark_buffer_dirty(bi->bi_parent);
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD (bi->bi_parent, bi->bi_position);
+        set_dc_size(t_dc, dc_size(t_dc) - cut_size);
+        mark_buffer_dirty(bi->bi_parent);
     }
     if (who_is_this (bh->b_data, bh->b_size) != THE_LEAF)
 	reiserfs_panic ("leaf_cut_from_buffer: bad leaf %lu: %b",
@@ -1191,7 +1205,8 @@
     if (del_num == 0)
 	return;
     
-    nr = (blkh = B_BLK_HEAD(bh))->blk_nr_item;
+    blkh = B_BLK_HEAD(bh);
+    nr = blkh_nr_item(blkh);
 
 #ifdef CONFIG_REISERFS_CHECK
     if (first < 0 || first + del_num > nr)
@@ -1209,11 +1224,11 @@
     ih = B_N_PITEM_HEAD (bh, first);
     
     /* location of unmovable item */
-    j = (first == 0) ? bh->b_size : (ih-1)->ih_item_location;
+    j = (first == 0) ? bh->b_size : ih_location(ih-1);
     
     /* delete items */
-    last_loc = ih[nr-1-first].ih_item_location;
-    last_removed_loc = ih[del_num-1].ih_item_location;
+    last_loc = ih_location( &(ih[nr-1-first]) );
+    last_removed_loc = ih_location( &(ih[del_num-1]));
     
     memmove (bh->b_data + last_loc + j - last_removed_loc,
 	     bh->b_data + last_loc, last_removed_loc - last_loc);
@@ -1223,16 +1238,21 @@
     
     /* change item location */
     for (i = first; i < nr - del_num; i ++)
-	ih[i-first].ih_item_location += j - last_removed_loc;
+        set_ih_location( &(ih[i-first]),
+            ih_location( &(ih[i-first]) ) + (j - last_removed_loc));
     
     /* sizes, item number */
-    blkh->blk_nr_item -= del_num;
-    blkh->blk_free_space += j - last_removed_loc + IH_SIZE * del_num;
+    set_blkh_nr_item(blkh, blkh_nr_item(blkh) - del_num);
+    set_blkh_free_space(blkh, blkh_free_space(blkh) +
+                                (j - last_removed_loc + IH_SIZE * del_num));
     
     mark_buffer_dirty(bh);
     
     if (bi->bi_parent) {
-	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size -= j - last_removed_loc + IH_SIZE * del_num;
+        struct disk_child *t_dc;
+        t_dc = B_N_CHILD (bi->bi_parent, bi->bi_position);
+        set_dc_size(t_dc, dc_size(t_dc) -
+                                (j - last_removed_loc + IH_SIZE * del_num));
 	mark_buffer_dirty(bi->bi_parent);
     }
     if (who_is_this (bh->b_data, bh->b_size) != THE_LEAF)
@@ -1273,28 +1293,28 @@
 
 
     /* first byte of dest item */
-    item = bh->b_data + ih->ih_item_location;
+    item = bh->b_data + ih_location(ih);
 
     /* entry head array */
     deh = B_I_DEH (bh, ih);
 
     /* new records will be pasted at this point */
-    insert_point = item + (before ? deh[before - 1].deh_location : (ih->ih_item_len - paste_size));
+    insert_point = item + (before ? deh_location(&(deh[before - 1])) : (ih_item_len(ih) - paste_size));
 
     /* adjust locations of records that will be AFTER new records */
     for (i = ih_entry_count (ih) - 1; i >= before; i --)
-	deh[i].deh_location += DEH_SIZE * new_entry_count;
+        set_deh_location(&(deh[i]), deh_location(&(deh[i])) + (DEH_SIZE * new_entry_count ) );
 
     /* adjust locations of records that will be BEFORE new records */
     for (i = 0; i < before; i ++)
-	deh[i].deh_location += paste_size;
+        set_deh_location(&(deh[i]), deh_location(&(deh[i])) + paste_size );
 
     old_entry_num = ih_entry_count (ih);
     //I_ENTRY_COUNT(ih) += new_entry_count;
     set_entry_count (ih, old_entry_num + new_entry_count);
 
     /* prepare space for pasted records */
-    memmove (insert_point + paste_size, insert_point, item + (ih->ih_item_len - paste_size) - insert_point);
+    memmove (insert_point + paste_size, insert_point, item + (ih_item_len(ih) - paste_size) - insert_point);
 
     /* copy new records */
     memcpy (insert_point + DEH_SIZE * new_entry_count, records,
@@ -1310,13 +1330,14 @@
 
     /* set locations of new records */
     for (i = 0; i < new_entry_count; i ++)
-	deh[i].deh_location +=
-	    (- new_dehs[new_entry_count - 1].deh_location + insert_point + DEH_SIZE * new_entry_count - item);
+        set_deh_location(&(deh[i]), deh_location(&(deh[i])) + 
+	    (- deh_location(&(new_dehs[new_entry_count - 1])) + insert_point +
+            DEH_SIZE * new_entry_count - item));
 
 
     /* change item key if neccessary (when we paste before 0-th entry */
     if (!before)
-	ih->ih_key.u.k_offset_v1.k_offset = new_dehs->deh_offset;
+	ih->ih_key.u.k_offset_v1.k_offset = new_dehs->deh_offset; /* both 32-bit LE */
 
 
 #ifdef CONFIG_REISERFS_CHECK
@@ -1325,13 +1346,13 @@
 	/* check record locations */
 	deh = B_I_DEH (bh, ih);
 	for (i = 0; i < ih_entry_count(ih); i ++) {
-	    next = (i < ih_entry_count(ih) - 1) ? deh[i + 1].deh_location : 0;
-	    prev = (i != 0) ? deh[i - 1].deh_location : 0;
+	    next = (i < ih_entry_count(ih) - 1) ? deh_location(&(deh[i + 1])) : 0;
+	    prev = (i != 0) ? deh_location(&(deh[i - 1])) : 0;
       
-	    if (prev && prev <= deh[i].deh_location)
-		reiserfs_warning ("vs-10240: leaf_paste_entries: directory item corrupted (%d %d)\n", prev, deh[i].deh_location);
-	    if (next && next >= deh[i].deh_location)
-		reiserfs_warning ("vs-10250: leaf_paste_entries: directory item corrupted (%d %d)\n", prev, deh[i].deh_location);
+	    if (prev && prev <= deh_location(&(deh[i])))
+		reiserfs_warning ("vs-10240: leaf_paste_entries: directory item corrupted (%d %d)\n", prev, deh_location(&(deh[i])));
+	    if (next && next >= deh_location(&(deh[i])))
+		reiserfs_warning ("vs-10250: leaf_paste_entries: directory item corrupted (%d %d)\n", prev, deh_location(&(deh[i])));
 	}
     }
 #endif
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/node_formats.c reiserfsprogs-devel/reiserfscore/node_formats.c
--- reiserfsprogs-3.x.0j/reiserfscore/node_formats.c	Fri Mar 30 08:09:03 2001
+++ reiserfsprogs-devel/reiserfscore/node_formats.c	Tue May  1 20:27:31 2001
@@ -22,14 +22,14 @@
     if (!is_leaf_block_head (buf))
 	return 0;
 
-    nr = le16_to_cpu (blkh->blk_nr_item);
+    nr = blkh_nr_item(blkh);
     if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN)))
 	/* item number is too big or too small */
 	return 0;
 
     ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
     used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location (ih));
-    if (used_space != blocksize - le16_to_cpu (blkh->blk_free_space))
+    if (used_space != blocksize - blkh_free_space(blkh))
 	/* free space does not match to calculated amount of use space */
 	return 0;
 
@@ -68,13 +68,13 @@
     if (!is_internal_block_head (buf))
 	return 0;
     
-    nr = le16_to_cpu (blkh->blk_nr_item);
+    nr = blkh_nr_item(blkh);
     if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE))
 	/* for internal which is not root we might check min number of keys */
 	return 0;
 
     used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
-    if (used_space != blocksize - le16_to_cpu (blkh->blk_free_space))
+    if (used_space != blocksize - blkh_free_space(blkh))
 	return 0;
 
     // one may imagine much more checks
@@ -319,29 +319,41 @@
     mode_t mode;
 
     if (ih_entry_count (ih) != 0xffff)
+    {
+        reiserfs_warning( stderr, "is_bad_sd: ih_entry_count(ih) [%04x]!= 0xffff\n", ih_entry_count(ih));
 	return 1;
+    }
 
     if (ih_key_format (ih) == KEY_FORMAT_1) {
 	struct stat_data_v1 * sd = (struct stat_data_v1 *)item;
 
 	if (ih_item_len (ih) != SD_V1_SIZE)
+        {
+            reiserfs_warning( stderr, "is_bad_sd: ih_item_len(ih) != SD_V1_SIZE\n" );
 	    /* old stat data must be 32 bytes long */
 	    return 1;
-	mode = le16_to_cpu (sd->sd_mode);
+        }
+	mode = sd_v1_mode(sd);
     } else if (ih_key_format (ih) == KEY_FORMAT_2) {
 	struct stat_data * sd = (struct stat_data *)item;
 
 	if (ih_item_len (ih) != SD_SIZE)
+        {
+            reiserfs_warning( stderr, "is_bad_sd: ih_item_len(ih) != SD_SIZE\n" );
 	    /* new stat data must be 44 bytes long */
 	    return 1;
-	mode = le16_to_cpu (sd->sd_mode);
+        }
+	mode = sd_v2_mode(sd);
     } else
 	return 1;
     
     if (!S_ISDIR (mode) && !S_ISREG (mode) && !S_ISCHR (mode) && 
 	!S_ISBLK (mode) && !S_ISLNK (mode) && !S_ISFIFO (mode) &&
 	!S_ISSOCK (mode))
+    {
+        reiserfs_warning( stderr, "is_bad_sd: bad mode\n" );
 	return 1;
+    }
 
     return 0;
 }
@@ -370,7 +382,7 @@
     for (i = 0; i < I_UNFM_NUM (ih); i ++) {
 	if (!ind [i])
 	    continue;
-	if (check_unfm_func && check_unfm_func (fs, ind [i]))
+	if (check_unfm_func && check_unfm_func (fs, le32_to_cpu(ind [i])))
 	    return 1;
     }
 
@@ -583,30 +595,27 @@
 
     if (is_stat_data_ih (ih)) {
 	retval = is_bad_sd (fs, ih, item);
-	/*
+	
 	if (retval)
-	reiserfs_warning (stderr, "is_bad_sd %H\n", ih);*/
+	reiserfs_warning (stderr, "is_bad_sd %H\n", ih);
 	return retval;
     }
     if (is_direntry_ih (ih)) {
 	retval =  is_bad_directory (fs, ih, item, bad_dir);
-	/*
 	if (retval)
-	reiserfs_warning (stderr, "is_bad_directory %H\n", ih);*/
+	reiserfs_warning (stderr, "is_bad_directory %H\n", ih);
 	return retval;
     }
     if (is_indirect_ih (ih)) {
 	retval = is_bad_indirect (fs, ih, item, check_unfm);
-	/*
 	if (retval)
-	reiserfs_warning (stderr, "is_bad_indirect %H\n", ih);*/
+	reiserfs_warning (stderr, "is_bad_indirect %H\n", ih);
 	return retval;
     }
     if (is_direct_ih (ih)) {
 	retval =  is_bad_direct (fs, ih, item);
-	/*
 	  if (retval)
-	  reiserfs_warning (stderr, "is_bad_direct %H\n", ih);*/
+	  reiserfs_warning (stderr, "is_bad_direct %H\n", ih);
 	return retval;
     }
     return 1;
@@ -626,7 +635,7 @@
     set_offset (key_format, &ih->ih_key, SD_OFFSET);
     set_type (key_format, &ih->ih_key, TYPE_STAT_DATA);
 
-    set_key_format (ih, key_format);
+    set_ih_key_format (ih, key_format);
     set_free_space (ih, MAX_US_INT);
 
     if (key_format == KEY_FORMAT_2)
@@ -634,26 +643,28 @@
         struct stat_data *sd_v2 = (struct stat_data *)sd;
 
 	set_ih_item_len (ih, SD_SIZE);
-        sd_v2->sd_mode = cpu_to_le16 (S_IFDIR + 0755);
-        sd_v2->sd_nlink = cpu_to_le32 (2);
-        sd_v2->sd_uid = 0;
-        sd_v2->sd_gid = 0;
-        sd_v2->sd_size = cpu_to_le64 (EMPTY_DIR_SIZE);
-        sd_v2->sd_atime = sd_v2->sd_ctime = sd_v2->sd_mtime = cpu_to_le32 (time (NULL));
-        sd_v2->u.sd_rdev = 0;
-        sd_v2->sd_blocks = cpu_to_le32 (dir_size2st_blocks (blocksize, EMPTY_DIR_SIZE));
+        set_sd_v2_mode(sd_v2, S_IFDIR + 0755);
+        set_sd_v2_nlink(sd_v2, 2);
+        sd_v2->sd_uid = 0; /* Safe if 0 */
+        sd_v2->sd_gid = 0; /* Safe if 0 */
+        set_sd_v2_size(sd_v2, EMPTY_DIR_SIZE);
+        set_sd_v2_atime(sd_v2, time(NULL));
+        sd_v2->sd_ctime = sd_v2->sd_mtime = sd_v2->sd_atime; /* all le */
+        sd_v2->u.sd_rdev = 0; /* Safe if 0 */
+        set_sd_v2_blocks(sd_v2, dir_size2st_blocks( blocksize, EMPTY_DIR_SIZE));
     }else{
         struct stat_data_v1 *sd_v1 = (struct stat_data_v1 *)sd;
 
 	set_ih_item_len (ih, SD_V1_SIZE);
-        sd_v1->sd_mode = cpu_to_le16 (S_IFDIR + 0755);
-        sd_v1->sd_nlink = cpu_to_le16 (2);
-        sd_v1->sd_uid = 0;
-        sd_v1->sd_gid = 0;
-        sd_v1->sd_size = cpu_to_le32 (EMPTY_DIR_SIZE_V1);
-        sd_v1->sd_atime = sd_v1->sd_ctime = sd_v1->sd_mtime = cpu_to_le32 (time (NULL));
-        sd_v1->u.sd_blocks = cpu_to_le32 (dir_size2st_blocks (blocksize, EMPTY_DIR_SIZE_V1));
-	sd_v1->sd_first_direct_byte = cpu_to_le32 (NO_BYTES_IN_DIRECT_ITEM);
+        set_sd_v1_mode(sd_v1, S_IFDIR + 0755);
+        set_sd_v1_nlink(sd_v1, 2);
+        sd_v1->sd_uid = 0; /* Safe if 0 */
+        sd_v1->sd_gid = 0; /* Safe if 0 */
+        set_sd_v1_size(sd_v1, EMPTY_DIR_SIZE_V1);
+        set_sd_v1_atime(sd_v1, time(NULL));
+        sd_v1->sd_ctime = sd_v1->sd_mtime = sd_v1->sd_atime; /* all le */
+        set_sd_v1_blocks(sd_v1, dir_size2st_blocks(blocksize, EMPTY_DIR_SIZE_V1));
+        set_sd_v1_first_direct_byte(sd_v1, NO_BYTES_IN_DIRECT_ITEM);
     }
 }
 
@@ -667,31 +678,31 @@
     deh = (struct reiserfs_de_head *)body;
     
     /* direntry header of "." */
-    deh[0].deh_offset = cpu_to_le32 (DOT_OFFSET);
-    deh[0].deh_dir_id = cpu_to_le32 (dirid);
-    deh[0].deh_objectid = cpu_to_le32 (objid);
-    deh[0].deh_state = 0;
+    set_deh_offset( &(deh[0]), DOT_OFFSET );
+    set_deh_dir_id( &(deh[0]), dirid );
+    set_deh_objectid( &(deh[0]), objid );
+    deh[0].deh_state = 0; /* Safe if 0 */
     set_bit (DEH_Visible, &(deh[0].deh_state));
   
     /* direntry header of ".." */
-    deh[1].deh_offset = cpu_to_le32 (DOT_DOT_OFFSET);
+    set_deh_offset( &(deh[1]), DOT_DOT_OFFSET );
     /* key of ".." for the root directory */
-    deh[1].deh_dir_id = cpu_to_le32 (par_dirid);
-    deh[1].deh_objectid = cpu_to_le32 (par_objid);
-    deh[1].deh_state = 0;
+    set_deh_dir_id( &(deh[1]), par_dirid );
+    set_deh_objectid( &(deh[1]), par_objid );
+    deh[1].deh_state = 0; /* Safe if 0 */
     set_bit (DEH_Visible, &(deh[1].deh_state));
 
     if (format == KEY_FORMAT_2) {
-	deh[0].deh_location = cpu_to_le16 (EMPTY_DIR_SIZE - ROUND_UP (strlen (".")));
-	deh[1].deh_location = cpu_to_le16 (deh_location (&deh[0]) - ROUND_UP (strlen ("..")));
+        set_deh_location( &(deh[0]), EMPTY_DIR_SIZE - ROUND_UP(strlen(".")));
+        set_deh_location( &(deh[1]), deh_location(&(deh[0])) - ROUND_UP(strlen( "..")));
     } else {
-	deh[0].deh_location = cpu_to_le16 (EMPTY_DIR_SIZE_V1 - strlen ("."));
-	deh[1].deh_location = cpu_to_le16 (deh_location (&deh[0]) - strlen (".."));
+        set_deh_location( &(deh[0]), EMPTY_DIR_SIZE_V1 - strlen( "." ) );
+        set_deh_location( &(deh[1]), deh_location(&(deh[0])) - strlen (".."));
     }
 
     /* copy ".." and "." */
-    memcpy (body + deh_location (&deh[0]), ".", 1);
-    memcpy (body + deh_location (&deh[1]), "..", 2);
+    memcpy (body + deh_location(&(deh[0])), ".", 1);
+    memcpy (body + deh_location(&(deh[1])), "..", 2);
     
 }
 
@@ -740,7 +751,7 @@
 {
     int type;
 
-    type = le16_to_cpu (key->u.k_offset_v2.k_type);
+    type = offset_v2_k_type( &(key->u.k_offset_v2) );
 
     if (type == 0 || type == 15)
 	return KEY_FORMAT_1;
@@ -754,7 +765,7 @@
     if (key_format (key) == KEY_FORMAT_1)
 	return le32_to_cpu (key->u.k_offset_v1.k_offset);
 
-    return le64_to_cpu (key->u.k_offset_v2.k_offset);
+    return offset_v2_k_offset( &(key->u.k_offset_v2 ) );
 }
 
 
@@ -786,7 +797,7 @@
 {
     if (key_format (key) == KEY_FORMAT_1)
 	return uniqueness2type (le32_to_cpu (key->u.k_offset_v1.k_uniqueness));
-    return le16_to_cpu (key->u.k_offset_v2.k_type);
+    return offset_v2_k_type( &(key->u.k_offset_v2) );
 }
 
 
@@ -826,7 +837,7 @@
     if (format == KEY_FORMAT_1)
 	key->u.k_offset_v1.k_uniqueness = cpu_to_le32 (type2uniqueness (type));
     else
-	key->u.k_offset_v2.k_type = cpu_to_le16 (type);
+	set_offset_v2_k_type( &(key->u.k_offset_v2), type );
 }
 
 
@@ -836,7 +847,7 @@
     if (format == KEY_FORMAT_1)
 	key->u.k_offset_v1.k_offset = cpu_to_le32 (offset);
     else
-	key->u.k_offset_v2.k_offset = cpu_to_le64 (offset);
+	set_offset_v2_k_offset( &(key->u.k_offset_v2), offset );
 	
 }
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/prints.c reiserfsprogs-devel/reiserfscore/prints.c
--- reiserfsprogs-3.x.0j/reiserfscore/prints.c	Fri Mar 30 08:20:02 2001
+++ reiserfsprogs-devel/reiserfscore/prints.c	Tue May  1 20:27:31 2001
@@ -63,7 +63,7 @@
     int len;
 
     key = *((const struct key **)(args[0]));
-    len = asprintf (&buffer, "%u %u", key->k_dir_id, key->k_objectid);
+    len = asprintf (&buffer, "%u %u", key_dir_id(key), key_objectid(key));
     FPRINTF;
 }
 
@@ -79,7 +79,10 @@
 
     key = *((const struct key **)(args[0]));
     len = asprintf (&buffer, "%u %u 0x%Lx %s",  
-		    key->k_dir_id, key->k_objectid, get_offset (key), key_of_what (key));
+		    key_dir_id(key),
+                    key_objectid(key),
+                    get_offset (key),
+                    key_of_what (key));
     FPRINTF;
 }
 
@@ -96,10 +99,11 @@
     ih = *((const struct item_head **)(args[0]));
     len = asprintf (&buffer, "%u %u 0x%Lx %s, "
 		    "len %u, entry count %u, fsck need %u, format %s",
-		    ih->ih_key.k_dir_id, ih->ih_key.k_objectid, 
+		    le32_to_cpu(ih->ih_key.k_dir_id),
+                    le32_to_cpu(ih->ih_key.k_objectid), 
 		    get_offset (&ih->ih_key), key_of_what (&ih->ih_key),
-		    ih->ih_item_len, ih_entry_count (ih), 
-		    ih->ih_format.fsck_need,
+		    ih_item_len(ih), ih_entry_count (ih), 
+                    ih_fsck_need(ih),
 		    ih_key_format (ih) == KEY_FORMAT_2 ? "new" : 
 		    ((ih_key_format (ih) == KEY_FORMAT_1) ? "old" : "BAD"));
     FPRINTF;
@@ -115,8 +119,8 @@
     int len;
 
     dc = *((const struct disk_child **)(args[0]));
-    len = asprintf (&buffer, "[dc_number=%u, dc_size=%u]", le32_to_cpu (dc->dc_block_number),
-		    le16_to_cpu (dc->dc_size));
+    len = asprintf (&buffer, "[dc_number=%u, dc_size=%u]", dc_block_number(dc),
+		    dc_size(dc));
     FPRINTF;
 }
 
@@ -308,9 +312,11 @@
 	name = name_in_entry (deh, i);
 	reiserfs_warning (fp, "%3d: \"%-25.*s\"(%3d)%20K%12d%5d, loc %u, state %x %s\n", 
 			  i, namelen, name, namelen,
+                          /* this gets converted in print_short_key() */
 			  (struct key *)&(deh->deh_dir_id),
-			  GET_HASH_VALUE (deh->deh_offset), GET_GENERATION_NUMBER (deh->deh_offset),
-			  deh_location (deh), deh->deh_state,
+			  GET_HASH_VALUE (deh_offset(deh)),
+                          GET_GENERATION_NUMBER (deh_offset(deh)),
+			  deh_location (deh), deh_state(deh),
 			  fs ? (is_properly_hashed (fs, name, namelen, deh_offset (deh)) ? "" : "(BROKEN)") : "??");
     }
 }
@@ -364,7 +370,7 @@
     ih = B_N_PITEM_HEAD (bh, item_num);
     unp = (__u32 *)B_I_PITEM (bh, ih);
 
-    if (ih->ih_item_len % UNFM_P_SIZE)
+    if (ih_item_len(ih) % UNFM_P_SIZE)
 	reiserfs_warning (fp, "print_indirect_item: invalid item len");  
 
     reiserfs_warning (fp, "%d pointers\n[ ", I_UNFM_NUM (ih));
@@ -389,27 +395,32 @@
 
 static int print_stat_data (FILE * fp, struct buffer_head * bh, struct item_head * ih, int alltimes)
 {
-    struct stat_data * sd = (struct stat_data *)B_I_PITEM (bh, ih);
-    struct stat_data_v1 * sd_v1 = (struct stat_data_v1 *)B_I_PITEM (bh, ih);
     int retval;
     
 
     /* we can not figure out whether it is new stat data or old by key_format
        macro. Stat data's key looks identical in both formats */
     if (ih_key_format (ih) == KEY_FORMAT_1) {
+        struct stat_data_v1 * sd_v1 = (struct stat_data_v1 *)B_I_PITEM (bh, ih);
 	reiserfs_warning (fp, "(OLD SD), mode %M, size %u, nlink %u, uid %d, FDB %d, mtime %s blocks %d", 
-		sd_v1->sd_mode, sd_v1->sd_size, sd_v1->sd_nlink, sd_v1->sd_uid, 
-		sd_v1->sd_first_direct_byte, timestamp (sd_v1->sd_mtime), sd_v1->u.sd_blocks);
-	retval = (S_ISLNK (sd_v1->sd_mode)) ? 1 : 0;
+		sd_v1_mode(sd_v1), sd_v1_size(sd_v1), sd_v1_nlink(sd_v1),
+                sd_v1_uid(sd_v1), sd_v1_first_direct_byte(sd_v1), timestamp
+                (sd_v1_mtime(sd_v1)), sd_v1_blocks(sd_v1));
+	retval = (S_ISLNK (sd_v1_mode(sd_v1))) ? 1 : 0;
+        if (alltimes)
+            reiserfs_warning (fp, "%s %s\n", timestamp (sd_v1_ctime(sd_v1)),
+                timestamp (sd_v1_atime(sd_v1)));
     } else {
+        struct stat_data * sd = (struct stat_data *)B_I_PITEM (bh, ih);
 	reiserfs_warning (fp, "(NEW SD), mode %M, size %Lu, nlink %u, mtime %s blocks %d", 
-		sd->sd_mode, sd->sd_size, sd->sd_nlink,
-		timestamp (sd->sd_mtime), sd->sd_blocks);
-	retval = (S_ISLNK (sd->sd_mode)) ? 1 : 0;
+		sd_v2_mode(sd), sd_v2_size(sd), sd_v2_nlink(sd),
+		timestamp (sd_v2_mtime(sd)), sd_v2_blocks(sd));
+	retval = (S_ISLNK (sd_v2_mode(sd))) ? 1 : 0;
+        if (alltimes)
+            reiserfs_warning (fp, "%s %s\n", timestamp (sd_v2_ctime(sd)),
+                timestamp (sd_v2_atime(sd)));
     }
 
-    if (alltimes)
-	reiserfs_warning (fp, "%s %s\n", timestamp (sd->sd_ctime), timestamp (sd->sd_atime));
     reiserfs_warning (fp, "\n");
     return retval;
 }
@@ -472,17 +483,17 @@
 
     if (!(print_mode & PRINT_LEAF_ITEMS)) {
 	reiserfs_warning (fp, "FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",
-			   &(ih->ih_key), &((ih + blkh->blk_nr_item - 1)->ih_key));
+			   &(ih->ih_key), &((ih + blkh_nr_item(blkh) - 1)->ih_key));
 	return 0;
     }
 
-    if (first < 0 || first > blkh->blk_nr_item - 1) 
+    if (first < 0 || first > blkh_nr_item(blkh) - 1) 
 	from = 0;
     else 
 	from = first;
 
-    if (last < 0 || last > blkh->blk_nr_item)
-	to = blkh->blk_nr_item;
+    if (last < 0 || last > blkh_nr_item(blkh))
+	to = blkh_nr_item(blkh);
     else
 	to = last;
 
@@ -515,7 +526,7 @@
 	    int j = 0;
 	    if (is_symlink || print_mode & PRINT_DIRECT_ITEMS) {
 		reiserfs_warning (fp, "\"");
-		while (j < ih[i].ih_item_len) {
+		while (j < ih_item_len(&(ih[i]))) {
 		    if (B_I_PITEM(bh,ih+i)[j] == 10)
 			reiserfs_warning (fp, "\\n");
 		    else
@@ -567,7 +578,7 @@
     reiserfs_warning (fp, "Journal block (first) %d\n", rs_journal_start (rs));
     reiserfs_warning (fp, "Journal dev %d\n", rs->s_v1.s_journal_dev);    
     reiserfs_warning (fp, "Journal orig size %d\n", rs_journal_size (rs));
-    reiserfs_warning (fp, "Filesystem state %s\n", (rs->s_v1.s_state == REISERFS_VALID_FS) ? "VALID" : "ERROR");
+    reiserfs_warning (fp, "Filesystem state %s\n", (rs_state(rs) == REISERFS_VALID_FS) ? "VALID" : "ERROR");
     if (fsck_state (rs) == TREE_IS_BUILT)
 	reiserfs_warning (fp, "fsck pass 2 completion code set\n");
  
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/reiserfslib.c reiserfsprogs-devel/reiserfscore/reiserfslib.c
--- reiserfsprogs-3.x.0j/reiserfscore/reiserfslib.c	Fri Mar 30 18:01:46 2001
+++ reiserfsprogs-devel/reiserfscore/reiserfslib.c	Tue May  1 20:27:32 2001
@@ -143,7 +143,6 @@
     fs->s_flags = flags; /* O_RDONLY or O_RDWR */
     fs->s_vp = vp;
 
-	
     reiserfs_read_bitmap_blocks(fs);
 	
     return fs;
@@ -604,8 +603,8 @@
     struct key * rdkey;
     __u32 hash;
 
-    entry_key.k_dir_id = dir->k_dir_id;
-    entry_key.k_objectid = dir->k_objectid;
+    entry_key.k_dir_id = cpu_to_le32(dir->k_dir_id);
+    entry_key.k_objectid = cpu_to_le32(dir->k_objectid);
     hash = hash_value (fs, name);
     set_type_and_offset (KEY_FORMAT_1, &entry_key, hash, TYPE_DIRENTRY);    
     *min_gen_counter = 0;
@@ -673,14 +672,14 @@
 
     memset (entry, 0, DEH_SIZE + ROUND_UP (strlen (name)));
     deh = (struct reiserfs_de_head *)entry;
-    deh->deh_location = 0;
-    deh->deh_offset = cpu_to_le32 (offset);
-    deh->deh_state = 0;
+    deh->deh_location = 0; /* Safe if 0 */
+    set_deh_offset(deh, offset);
+    deh->deh_state = 0; /* Safe if 0 */
     mark_de_visible (deh);
 
     /* key of object entry will point to */
-    deh->deh_dir_id = cpu_to_le32 (key->k_dir_id);
-    deh->deh_objectid = cpu_to_le32 (key->k_objectid);
+    deh->deh_dir_id = key->k_dir_id; /* both little endian */
+    deh->deh_objectid = key->k_objectid; /* both little endian */
 
     memcpy ((char *)(deh + 1), name, strlen (name));
     return entry;
@@ -713,7 +712,7 @@
 	hash = DOT_DOT_OFFSET;
     set_type_and_offset (KEY_FORMAT_1, &(entry_ih.ih_key),
 			 hash, TYPE_DIRENTRY);
-    set_key_format (&entry_ih, KEY_FORMAT_1);
+    set_ih_key_format (&entry_ih, KEY_FORMAT_1);
     set_entry_count (&entry_ih, 1);
     if (SB_VERSION (fs) == REISERFS_VERSION_2)
 	item_len = DEH_SIZE + ROUND_UP (strlen (name));
@@ -722,7 +721,7 @@
     set_ih_item_len (&entry_ih, item_len);
 
     /* fsck may need to insert item which was not reached yet */
-    entry_ih.ih_format.fsck_need = fsck_need;
+    set_ih_fsck_need( &entry_ih, fsck_need );
 
     entry = make_entry (0, name, key, get_offset (&(entry_ih.ih_key)));
 
@@ -733,7 +732,7 @@
 	break;
 
     case DIRECTORY_NOT_FOUND:
-	((struct reiserfs_de_head *)entry)->deh_location = cpu_to_le16 (DEH_SIZE);
+        set_deh_location( (struct reiserfs_de_head *)entry, DEH_SIZE );
 	reiserfs_insert_item (fs, &path, &entry_ih, entry);
 	break;
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/reiserfscore/stree.c reiserfsprogs-devel/reiserfscore/stree.c
--- reiserfsprogs-3.x.0j/reiserfscore/stree.c	Sun Mar 25 16:30:23 2001
+++ reiserfsprogs-devel/reiserfscore/stree.c	Tue May  1 20:27:32 2001
@@ -67,9 +67,9 @@
     p_s_key2 = (__u32 *)k2;
 
     for( ; n_key_length--; ++p_s_key1, ++p_s_key2 ) {
-	if ( *p_s_key1 < *p_s_key2 )
+	if ( le32_to_cpu(*p_s_key1) < le32_to_cpu(*p_s_key2) )
 	    return -1;
-	if ( *p_s_key1 > *p_s_key2 )
+	if ( le32_to_cpu(*p_s_key1) > le32_to_cpu(*p_s_key2) )
 	    return 1;
     }
 
diff -ruP -x CVS reiserfsprogs-3.x.0j/resize_reiserfs/do_shrink.c reiserfsprogs-devel/resize_reiserfs/do_shrink.c
--- reiserfsprogs-3.x.0j/resize_reiserfs/do_shrink.c	Sat Mar 10 08:33:12 2001
+++ reiserfsprogs-devel/resize_reiserfs/do_shrink.c	Mon Mar 26 18:35:21 2001
@@ -133,7 +133,7 @@
 			unsigned long moved_block;
 			moved_block = move_formatted_block(B_N_CHILD_NUM(bh, i), bnd, h+1);
 			if (moved_block) {
-				set_dc_block_number (bh, i, moved_block);
+				set_child_block_number (bh, i, moved_block);
 				mark_buffer_dirty(bh);
 			}
 		}	
diff -ruP -x CVS reiserfsprogs-3.x.0j/version.h reiserfsprogs-devel/version.h
--- reiserfsprogs-3.x.0j/version.h	Wed Mar 28 08:54:19 2001
+++ reiserfsprogs-devel/version.h	Tue May  1 20:30:39 2001
@@ -2,7 +2,7 @@
  * Copyright 2000 Hans Reiser
  */
 
-#define REISERFSPROGS_VERSION "3.x.0j"
+#define REISERFSPROGS_VERSION "3.x.0j-esafe"
 
 #define print_banner(prog) \
 fprintf (stderr, "\n<-------------%s, 2001------------->\nreiserfsprogs %s\n", \
